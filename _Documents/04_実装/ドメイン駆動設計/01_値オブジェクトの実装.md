# 値オブジェクト (Value Object) - Rust版

## 参考

[値オブジェクト (Value Object)](https://zenn.dev/yamachan0625/books/ddd-hands-on/viewer/chapter8_value_object)

## 値オブジェクトとは

値オブジェクト (Value Object) は、DDDにおけるドメインモデルの中心的な要素で、ドメイン内の様々な値の概念をモデル化するために用いられます。

## 値の問題点

例えば、以下のようなコードを考えてみましょう：

```rust
let book_id: String = String::from("xxxxxxxx");
```

このコードは文法的には正しいですが、`book_id`の値として「xxxxxxxx」は本当に正しいでしょうか？

実際には、`BookId`はISBNコードである必要がありますが、このままでは：
- **不正な状態で存在することが可能**
- **正しい値が何かわからない**

という問題があります。これではバグの温床になってしまいます。

## 値の特徴

値オブジェクトを実装する前に、値が持つべき3つの特徴を理解しましょう：

### 1. 不変に保つことができる

プリミティブ型の値は不変です。Rustでは、値の不変性はデフォルトの動作です：

```rust
// 文字列リテラルは不変
let text = "あ";
// text = "い"; // エラー: 再代入できない
```

### 2. 値同士が等しいか比較できる

プリミティブな値は、その内容によって等価性が判断されます：

```rust
println!("{}", "Hello" == "Hello");  // true
println!("{}", "Hello" == "Goodbye"); // false
```

### 3. 副作用がない

値の操作は、他の状態に影響を与えません：

```rust
let text = "Hello";
let upper = text.to_uppercase();
println!("{}", upper); // "HELLO"
println!("{}", text);  // "Hello" (元の値は変更されていない)
```

## 値オブジェクトの実装

Rustで基本的な値オブジェクトを実装してみましょう：

```rust
use std::fmt;

#[derive(Debug, Clone)]
pub struct BookId {
    value: String,
}

impl BookId {
    pub fn new(value: String) -> Self {
        Self { value }
    }

    pub fn value(&self) -> &str {
        &self.value
    }
}

// 等価性の比較を実装
impl PartialEq for BookId {
    fn eq(&self, other: &Self) -> bool {
        self.value == other.value
    }
}

impl Eq for BookId {}
```

### 値の特徴の実装確認

#### 1. 不変に保つことができる

```rust
// 値オブジェクト自体を変更することはできません
// BookId::new("9784167158057".to_string()) = BookId::new("9784167158057".to_string()); // エラー

// valueフィールドは所有権を持ち、外部から変更できません
let book_id = BookId::new("9784167158057".to_string());
// book_id.value = "9784167158057".to_string(); // エラー: valueはprivate
```

#### 2. 値同士が等しいか比較できる

```rust
let book_id1 = BookId::new("9784167158057".to_string());
let book_id2 = BookId::new("9784167158057".to_string());
let book_id3 = BookId::new("9780306406157".to_string());

println!("{}", book_id1 == book_id2); // true
println!("{}", book_id1 == book_id3); // false
```

#### 3. 副作用がない

```rust
let book_id = BookId::new("9784167158057".to_string());
let _result = book_id == book_id;
println!("{}", book_id.value()); // "9784167158057" (値自体が変更されていない)
```

## ビジネスルールの適用

値オブジェクトの真髄は、値にビジネスルールを適用できる点にあります。ISBNのバリデーションを追加しましょう：

```rust
use thiserror::Error;

#[derive(Debug, Error)]
pub enum BookIdError {
    #[error("ISBNの文字数が不正です")]
    InvalidLength,
    #[error("不正なISBNの形式です")]
    InvalidFormat,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct BookId {
    value: String,
}

impl BookId {
    const MAX_LENGTH: usize = 13;
    const MIN_LENGTH: usize = 10;

    pub fn new(value: String) -> Result<Self, BookIdError> {
        Self::validate(&value)?;
        Ok(Self { value })
    }

    fn validate(isbn: &str) -> Result<(), BookIdError> {
        if isbn.len() < Self::MIN_LENGTH || isbn.len() > Self::MAX_LENGTH {
            return Err(BookIdError::InvalidLength);
        }

        if !Self::is_valid_isbn10(isbn) && !Self::is_valid_isbn13(isbn) {
            return Err(BookIdError::InvalidFormat);
        }

        Ok(())
    }

    fn is_valid_isbn10(isbn: &str) -> bool {
        // ISBN-10のバリデーションロジック
        isbn.len() == 10 && isbn.chars().all(|c| c.is_ascii_digit())
    }

    fn is_valid_isbn13(isbn: &str) -> bool {
        // ISBN-13のバリデーションロジック
        isbn.starts_with("978") && isbn.len() == 13 && isbn.chars().all(|c| c.is_ascii_digit())
    }

    pub fn value(&self) -> &str {
        &self.value
    }

    pub fn to_isbn(&self) -> String {
        if self.value.len() == 10 {
            // ISBN-10の場合
            let group_identifier = &self.value[0..1];
            let publisher_code = &self.value[1..3];
            let book_code = &self.value[3..9];
            let checksum = &self.value[9..10];
            format!("ISBN{}-{}-{}-{}", group_identifier, publisher_code, book_code, checksum)
        } else {
            // ISBN-13の場合
            let isbn_prefix = &self.value[0..3];
            let group_identifier = &self.value[3..4];
            let publisher_code = &self.value[4..6];
            let book_code = &self.value[6..12];
            let checksum = &self.value[12..13];
            format!("ISBN{}-{}-{}-{}-{}", isbn_prefix, group_identifier, publisher_code, book_code, checksum)
        }
    }
}
```

### コンストラクタでのバリデーション

Rustでは、`new`関数で`Result`型を返すことで、不正な値での生成を防ぎます：

```rust
// 正常なケース
let book_id = BookId::new("9784167158057".to_string()).unwrap();

// エラーケース
match BookId::new("977".to_string()) {
    Ok(id) => println!("成功: {}", id.value()),
    Err(e) => println!("エラー: {}", e), // "エラー: ISBNの文字数が不正です"
}
```

## テスト

値オブジェクトのビジネスルールが正しく実装されているかを保証するためにテストを書きましょう：

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_valid_format() {
        let book_id = BookId::new("9784167158057".to_string());
        assert!(book_id.is_ok());
        assert_eq!(book_id.unwrap().value(), "9784167158057");

        let book_id = BookId::new("4167158051".to_string());
        assert!(book_id.is_ok());
        assert_eq!(book_id.unwrap().value(), "4167158051");
    }

    #[test]
    fn test_equals() {
        let book_id1 = BookId::new("9784167158057".to_string()).unwrap();
        let book_id2 = BookId::new("9784167158057".to_string()).unwrap();
        let book_id3 = BookId::new("9781234567890".to_string()).unwrap();

        assert_eq!(book_id1, book_id2);
        assert_ne!(book_id1, book_id3);
    }

    #[test]
    fn test_to_isbn_13() {
        let book_id = BookId::new("9784167158057".to_string()).unwrap();
        assert_eq!(book_id.to_isbn(), "ISBN978-4-16-715805-7");
    }

    #[test]
    fn test_to_isbn_10() {
        let book_id = BookId::new("4167158051".to_string()).unwrap();
        assert_eq!(book_id.to_isbn(), "ISBN4-16-715805-1");
    }

    #[test]
    fn test_invalid_length() {
        let result = BookId::new("1".repeat(101));
        assert!(result.is_err());

        let result = BookId::new("1".repeat(9));
        assert!(result.is_err());
    }

    #[test]
    fn test_invalid_format() {
        let result = BookId::new("9994167158057".to_string());
        assert!(result.is_err());
    }
}
```

テストを実行：

```bash
cargo test
```

## 共通処理の抽象化（リファクタリング）

すべての値オブジェクトで共通の処理を trait として定義できます：

```rust
pub trait ValueObject: PartialEq + Eq + Clone {
    type Value;
    type Error;

    fn new(value: Self::Value) -> Result<Self, Self::Error>
    where
        Self: Sized;
    
    fn value(&self) -> &Self::Value;
}

// BookIdでの利用例
impl ValueObject for BookId {
    type Value = String;
    type Error = BookIdError;

    fn new(value: String) -> Result<Self, Self::Error> {
        Self::validate(&value)?;
        Ok(Self { value })
    }

    fn value(&self) -> &String {
        &self.value
    }
}
```

## TypeScriptとRustの主な違い

1. **エラーハンドリング**: TypeScriptでは`throw`、Rustでは`Result`型を使用
2. **不変性**: Rustではデフォルトで不変、TypeScriptでは`readonly`が必要
3. **等価性**: Rustでは`PartialEq`トレイトの実装、TypeScriptでは`equals`メソッド
4. **型安全性**: Rustはコンパイル時に厳格なチェック、TypeScriptは構造的型付け

## まとめ

- **値オブジェクトは値である**
- **Rustの型システムと所有権により、より安全な実装が可能**
- **`Result`型により、不正な値の生成を型レベルで防げる**
- **値オブジェクト自身がドメイン内の値のドキュメントになる**
- **テストによって品質を担保できる**

RustでのDDD実装は、言語の特性（所有権、型システム、パターンマッチング）を活かすことで、TypeScript以上に堅牢なドメインモデルを構築できます。