# 集約の実装 (Rust版)

## 集約とは

集約 (Aggregate) とは、関連するオブジェクト群を 1 つのユニットとして管理するための手法です。集約は、1 つのルートエンティティ（集約ルート）と、それに関連するエンティティや値オブジェクトで構成されます。集約は、ビジネスルールとデータの整合性を維持するために設計されます。

たとえば、「プレイヤー」と「デッキ」には整合性が必要です。プレイヤーを削除できるのはデッキが存在しない場合のみで、プレイヤーを削除したらデッキデータも削除されなければデータの整合性が保たれません。このように関連するオブジェクト群を 1 つのユニットとして扱うことで、データの整合性を保つことができます。

また、集約は**リポジトリの入出力の単位**で、集約単位で入出力することで整合性が保たれたデータを確実に管理することができます。集約の設計が適切であれば、データベースに保存されているデータは、ビジネスルールに従って常に一貫性を保つことが可能になります。

> **Note:** リポジトリとはデータの永続化を行うコンポーネントで、入出力の単位は集約となります。集約で整合性が保たれたデータをそのままデータベースへ反映するために、集約内のデータは同一のトランザクション内ですべて更新されます。

## Player 集約の実装

それでは、集約ルートである `Player` ルートエンティティを実装していきましょう。プレイヤーは複数のユニットを持ち、それらのユニットはプレイヤーに紐づいています。

### ドメインモデルの確認

```
Player 集約
  Player (ルートエンティティ)
    - PlayerId: プレイヤーID
    - PlayerName: プレイヤー名
    - Level: レベル
    - Deck: デッキ (エンティティ)
      - DeckId: デッキID
      - DeckName: デッキ名
      - UnitIds: ユニットIDのリスト
      - MaxSize: 最大サイズ
```

### デメテルの法則

コードの実装に入る前に集約にとって重要な**デメテルの法則 (Law of Demeter)** について説明します。デメテルの法則は、オブジェクト指向プログラミングにおける設計原則の一つです。この法則は、とくにオブジェクト間の相互作用に焦点を当てており、**「最小知識の原則」** とも呼ばれます。この原則に従うことで、システム内の異なるオブジェクト間の密な結合を減らし、より保守しやすく、理解しやすいコードを作成できます。

#### デメテルの法則の基本原則

[Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%87%E3%83%A1%E3%83%86%E3%83%AB%E3%81%AE%E6%B3%95%E5%89%87) ではデメテルの法則では、`オブジェクト O` 上の`メソッド M` が呼び出してもよいメソッドは以下のオブジェクトに属するメソッドのみに限定されると説明されています。

1. O それ自身
2. M の引数に渡されたオブジェクト
3. M の内部でインスタンス化されたオブジェクト
4. O を直接的に構成するオブジェクト（O のインスタンス変数）

文章だけでは理解しづらいので、簡単な例を用いて確認しましょう。

**デメテルの法則適用前のコード例:**

```rust
pub struct Deck {
    unit_count: usize,
}

impl Deck {
    pub fn unit_count(&self) -> usize {
        self.unit_count
    }
}

pub struct Player {
    pub deck: Deck,  // publicフィールド
}

// 使用例
let player = Player { deck: Deck { unit_count: 10 } };
let count = player.deck.unit_count();  // Playerを経由してDeckの内部にアクセス
```

この例では、`Player` 構造体は `Deck` 構造体を通じて `unit_count` にアクセスしています。これは `Player` が `Deck` の内部構造（Deck が unit_count を持っていること）に依存しており、結合度が高いです。

**デメテルの法則適用後のコード例:**

```rust
pub struct Deck {
    unit_count: usize,
}

impl Deck {
    pub fn unit_count(&self) -> usize {
        self.unit_count
    }
}

pub struct Player {
    deck: Deck,  // privateフィールド
}

impl Player {
    pub fn get_deck_unit_count(&self) -> usize {
        self.deck.unit_count()
    }
}

// 使用例
let player = Player { deck: Deck { unit_count: 10 } };
let count = player.get_deck_unit_count();  // Playerのメソッドを通じてアクセス
```

この例では、`Player` 構造体は自身のメソッドを通じて `Deck` の `unit_count` を取得しています。これにより、`Player` は `Deck` の内部構造に依存することなく、より疎結合なコードになります。

#### 集約とデメテルの法則

デメテルの法則は集約実装のガイドラインとなります。集約は、関連オブジェクトを 1 つのユニットとして管理します。集約の内部オブジェクトが密接に関連し合っている一方で、集約の外部からの操作は必ず集約ルートを介して行われなければいけません。

上記の例で言うと、`Deck` エンティティは Player 集約ルートでのみ操作できるように制御する必要があります。これはデメテルの法則に沿っています。このようにすることで、集約外のオブジェクトが集約内の詳細について知る必要がなくなるため、疎結合になります。

また、集約の内部構造や状態に直接アクセスすることができなくなるため、ドメインルールの漏洩や整合性が破壊されることを防ぐことができます。

### 実装

それでは、デメテルの法則にしたがって `Player` ルートエンティティを実装します。

```rust
use uuid::Uuid;

// 値オブジェクト: PlayerId
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct PlayerId(String);

impl PlayerId {
    pub fn new() -> Self {
        Self(Uuid::new_v4().to_string())
    }

    pub fn from_string(value: String) -> Self {
        Self(value)
    }

    pub fn value(&self) -> &str {
        &self.0
    }
}

// 値オブジェクト: PlayerName
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct PlayerName(String);

impl PlayerName {
    pub fn new(value: String) -> Result<Self, String> {
        if value.is_empty() {
            return Err("プレイヤー名は空にできません".to_string());
        }
        if value.len() > 50 {
            return Err("プレイヤー名は50文字以内である必要があります".to_string());
        }
        Ok(Self(value))
    }

    pub fn value(&self) -> &str {
        &self.0
    }
}

// 値オブジェクト: Level
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Level(u32);

impl Level {
    pub fn new(value: u32) -> Result<Self, String> {
        if value < 1 {
            return Err("レベルは1以上である必要があります".to_string());
        }
        if value > 100 {
            return Err("レベルは100以下である必要があります".to_string());
        }
        Ok(Self(value))
    }

    pub fn value(&self) -> u32 {
        self.0
    }
}

// 値オブジェクト: DeckId
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct DeckId(String);

impl DeckId {
    pub fn new() -> Self {
        Self(Uuid::new_v4().to_string())
    }

    pub fn from_string(value: String) -> Self {
        Self(value)
    }

    pub fn value(&self) -> &str {
        &self.0
    }
}

// 値オブジェクト: DeckName
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct DeckName(String);

impl DeckName {
    pub fn new(value: String) -> Result<Self, String> {
        if value.is_empty() {
            return Err("デッキ名は空にできません".to_string());
        }
        Ok(Self(value))
    }

    pub fn value(&self) -> &str {
        &self.0
    }
}

// エンティティ: Deck
pub struct Deck {
    deck_id: DeckId,
    deck_name: DeckName,
    unit_ids: Vec<String>,
    max_size: usize,
}

impl Deck {
    fn new(deck_id: DeckId, deck_name: DeckName, unit_ids: Vec<String>, max_size: usize) -> Self {
        Self {
            deck_id,
            deck_name,
            unit_ids,
            max_size,
        }
    }

    pub fn create(deck_name: DeckName) -> Self {
        Self::new(DeckId::new(), deck_name, Vec::new(), 5)
    }

    pub fn reconstruct(
        deck_id: DeckId,
        deck_name: DeckName,
        unit_ids: Vec<String>,
        max_size: usize,
    ) -> Self {
        Self::new(deck_id, deck_name, unit_ids, max_size)
    }

    pub fn add_unit(&mut self, unit_id: String) -> Result<(), String> {
        if self.unit_ids.len() >= self.max_size {
            return Err(format!("デッキには最大{}体までしか追加できません", self.max_size));
        }
        if self.unit_ids.contains(&unit_id) {
            return Err("このユニットは既にデッキに含まれています".to_string());
        }
        self.unit_ids.push(unit_id);
        Ok(())
    }

    pub fn remove_unit(&mut self, unit_id: &str) -> Result<(), String> {
        let initial_len = self.unit_ids.len();
        self.unit_ids.retain(|id| id != unit_id);
        if self.unit_ids.len() == initial_len {
            return Err("指定されたユニットIDはデッキに含まれていません".to_string());
        }
        Ok(())
    }

    pub fn change_name(&mut self, new_name: DeckName) {
        self.deck_name = new_name;
    }

    pub fn is_empty(&self) -> bool {
        self.unit_ids.is_empty()
    }

    pub fn deck_id(&self) -> &DeckId {
        &self.deck_id
    }

    pub fn deck_name(&self) -> &DeckName {
        &self.deck_name
    }

    pub fn unit_ids(&self) -> &[String] {
        &self.unit_ids
    }

    pub fn unit_count(&self) -> usize {
        self.unit_ids.len()
    }

    pub fn max_size(&self) -> usize {
        self.max_size
    }
}

// 集約ルート: Player
pub struct Player {
    player_id: PlayerId,
    player_name: PlayerName,
    level: Level,
    deck: Deck,
}

impl Player {
    // privateなコンストラクタ
    fn new(player_id: PlayerId, player_name: PlayerName, level: Level, deck: Deck) -> Self {
        Self {
            player_id,
            player_name,
            level,
            deck,
        }
    }

    // 新規エンティティの生成
    pub fn create(player_name: PlayerName, deck_name: DeckName) -> Self {
        let player_id = PlayerId::new();
        let level = Level::new(1).unwrap();
        let deck = Deck::create(deck_name);

        Self::new(player_id, player_name, level, deck)
    }

    // エンティティの再構築（リポジトリから取得時に使用）
    pub fn reconstruct(
        player_id: PlayerId,
        player_name: PlayerName,
        level: Level,
        deck: Deck,
    ) -> Self {
        Self::new(player_id, player_name, level, deck)
    }

    // 削除（デッキが空の場合のみ削除可能）
    pub fn delete(&self) -> Result<(), String> {
        if !self.deck.is_empty() {
            return Err("デッキにユニットが含まれている場合は削除できません".to_string());
        }
        Ok(())
    }

    // プレイヤー名を変更
    pub fn change_name(&mut self, new_name: PlayerName) {
        self.player_name = new_name;
    }

    // レベルアップ
    pub fn level_up(&mut self) -> Result<(), String> {
        let new_level_value = self.level.value() + 1;
        match Level::new(new_level_value) {
            Ok(new_level) => {
                self.level = new_level;
                Ok(())
            }
            Err(e) => Err(e),
        }
    }

    // デッキにユニットを追加（集約ルートを介してDeckを操作）
    pub fn add_unit_to_deck(&mut self, unit_id: String) -> Result<(), String> {
        self.deck.add_unit(unit_id)
    }

    // デッキからユニットを削除（集約ルートを介してDeckを操作）
    pub fn remove_unit_from_deck(&mut self, unit_id: &str) -> Result<(), String> {
        self.deck.remove_unit(unit_id)
    }

    // デッキ名を変更（集約ルートを介してDeckを操作）
    pub fn change_deck_name(&mut self, new_deck_name: DeckName) {
        self.deck.change_name(new_deck_name);
    }

    // デッキが満杯かどうかを確認
    pub fn is_deck_full(&self) -> bool {
        self.deck.unit_count() >= self.deck.max_size()
    }

    // ゲッター
    pub fn player_id(&self) -> &PlayerId {
        &self.player_id
    }

    pub fn player_name(&self) -> &PlayerName {
        &self.player_name
    }

    pub fn level(&self) -> &Level {
        &self.level
    }

    pub fn deck_id(&self) -> &DeckId {
        self.deck.deck_id()
    }

    pub fn deck_name(&self) -> &DeckName {
        self.deck.deck_name()
    }

    pub fn deck_unit_ids(&self) -> &[String] {
        self.deck.unit_ids()
    }

    pub fn deck_unit_count(&self) -> usize {
        self.deck.unit_count()
    }
}
```

基本的な設計方針は前章で学んだエンティティと同じです。違いは `Deck` エンティティの値やメソッドへの参照がすべて `Player` ルートエンティティを介して行われている点です。これにより、デメテルの法則に沿ったコードになっています。

### 実装のポイント

1. **Deck エンティティをprivateフィールドとして保持**
   - 外部から直接アクセスできないようにすることで、集約の整合性を保護

2. **集約ルートを介した操作**
   - `add_unit_to_deck`、`remove_unit_from_deck` など、Deck の操作は Player を介して行う
   - これにより、ビジネスルールを Player 集約で一元管理できる

3. **ゲッターメソッドでの委譲**
   - `deck_unit_count()` などのメソッドで、内部の Deck の情報を公開
   - 直接 Deck を公開せず、必要な情報のみを提供

## Player 集約のテスト

それではテストを書いていきましょう。

```rust
#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_player() -> Player {
        let player_name = PlayerName::new("テストプレイヤー".to_string()).unwrap();
        let deck_name = DeckName::new("テストデッキ".to_string()).unwrap();
        Player::create(player_name, deck_name)
    }

    #[test]
    fn test_create_player_with_default_values() {
        let player = create_test_player();

        assert_eq!(player.player_name().value(), "テストプレイヤー");
        assert_eq!(player.level().value(), 1);
        assert_eq!(player.deck_name().value(), "テストデッキ");
        assert_eq!(player.deck_unit_count(), 0);
    }

    #[test]
    fn test_add_unit_to_deck() {
        let mut player = create_test_player();
        let unit_id = "unit-001".to_string();

        player.add_unit_to_deck(unit_id.clone()).unwrap();

        assert_eq!(player.deck_unit_count(), 1);
        assert!(player.deck_unit_ids().contains(&unit_id));
    }

    #[test]
    fn test_add_unit_to_deck_max_size() {
        let mut player = create_test_player();

        // 最大数まで追加
        for i in 0..5 {
            player
                .add_unit_to_deck(format!("unit-{:03}", i))
                .unwrap();
        }

        assert_eq!(player.deck_unit_count(), 5);
        assert!(player.is_deck_full());

        // 最大数を超えて追加しようとするとエラー
        let result = player.add_unit_to_deck("unit-006".to_string());
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err(),
            "デッキには最大5体までしか追加できません"
        );
    }

    #[test]
    fn test_add_duplicate_unit_to_deck() {
        let mut player = create_test_player();
        let unit_id = "unit-001".to_string();

        player.add_unit_to_deck(unit_id.clone()).unwrap();

        // 同じユニットを追加しようとするとエラー
        let result = player.add_unit_to_deck(unit_id);
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err(),
            "このユニットは既にデッキに含まれています"
        );
    }

    #[test]
    fn test_remove_unit_from_deck() {
        let mut player = create_test_player();
        let unit_id = "unit-001".to_string();

        player.add_unit_to_deck(unit_id.clone()).unwrap();
        assert_eq!(player.deck_unit_count(), 1);

        player.remove_unit_from_deck(&unit_id).unwrap();
        assert_eq!(player.deck_unit_count(), 0);
    }

    #[test]
    fn test_remove_non_existent_unit_from_deck() {
        let mut player = create_test_player();

        let result = player.remove_unit_from_deck("non-existent-unit");
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err(),
            "指定されたユニットIDはデッキに含まれていません"
        );
    }

    #[test]
    fn test_delete_player_with_units_in_deck() {
        let mut player = create_test_player();
        player.add_unit_to_deck("unit-001".to_string()).unwrap();

        let result = player.delete();
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err(),
            "デッキにユニットが含まれている場合は削除できません"
        );
    }

    #[test]
    fn test_delete_player_with_empty_deck() {
        let player = create_test_player();

        let result = player.delete();
        assert!(result.is_ok());
    }

    #[test]
    fn test_change_player_name() {
        let mut player = create_test_player();
        let new_name = PlayerName::new("新しいプレイヤー名".to_string()).unwrap();

        player.change_name(new_name.clone());
        assert_eq!(player.player_name().value(), "新しいプレイヤー名");
    }

    #[test]
    fn test_change_deck_name() {
        let mut player = create_test_player();
        let new_deck_name = DeckName::new("新しいデッキ名".to_string()).unwrap();

        player.change_deck_name(new_deck_name.clone());
        assert_eq!(player.deck_name().value(), "新しいデッキ名");
    }

    #[test]
    fn test_level_up() {
        let mut player = create_test_player();

        player.level_up().unwrap();
        assert_eq!(player.level().value(), 2);

        player.level_up().unwrap();
        assert_eq!(player.level().value(), 3);
    }

    #[test]
    fn test_level_up_max_level() {
        let player_id = PlayerId::new();
        let player_name = PlayerName::new("テストプレイヤー".to_string()).unwrap();
        let level = Level::new(100).unwrap();
        let deck_name = DeckName::new("テストデッキ".to_string()).unwrap();
        let deck = Deck::create(deck_name);

        let mut player = Player::reconstruct(player_id, player_name, level, deck);

        let result = player.level_up();
        assert!(result.is_err());
    }

    #[test]
    fn test_is_deck_full() {
        let mut player = create_test_player();

        assert!(!player.is_deck_full());

        // 最大数まで追加
        for i in 0..5 {
            player
                .add_unit_to_deck(format!("unit-{:03}", i))
                .unwrap();
        }

        assert!(player.is_deck_full());
    }
}
```

### テストのポイント

`add_unit_to_deck` メソッドではデメテルの法則に従い、`Deck` エンティティの `add_unit` メソッドを呼び出しています。`add_unit` メソッドのロジックのテストは `Deck` のテストで行っているため、`Player` ルートエンティティの `add_unit_to_deck` メソッドのテストでは、適切に動作することを確認します。

このようにテストすることで、`Deck` エンティティの `add_unit` メソッドのロジックが変更されても、修正は `Deck` のテストだけで済み、`Player` のテストを変更する必要がなくなります。

## 集約の設計上のルール

集約の設計にはいくつかのルールがあります。ここでは重要な 3 つを紹介します。

- **集約は小さくする**
- **集約間は識別子 (ID) で参照する**
- **集約の外部では結果整合性を用いる**

### 集約は小さくする

集約の設計をする上で一番難しいのが、集約の範囲を決めることです。基本的に集約の範囲は、なるべく小さくしたほうが良いとされています。

「整合性」だけに焦点を当てて設計をしてしまうと集約の範囲が肥大しがちです。たとえば、プレイヤー集約が以下のようになっているとします。

```rust
pub struct Player {
    player_id: PlayerId,
    player_name: PlayerName,
    level: Level,
    deck: Deck,
    match_history: Vec<MatchRecord>,  // マッチ履歴（1対n）
    achievements: Vec<Achievement>,   // 達成実績（1対n）
    friends: Vec<FriendId>,           // フレンドリスト（1対n）
}
```

これらすべてを一つの集約として捉えようとすると、その集約は複雑になり、管理が困難になります。集約は **1 集約 1 トランザクション**でデータベースに反映しなければなりません。このため、プレイヤーの一部データを更新するために集約内のすべての要素を一度データベースから読み込み、すべて同時に更新する必要が生じます。これは明らかなオーバーヘッドです。

また、集約の範囲が大きいとトランザクションのロック時間が長くなり、データベースのパフォーマンスが悪化したり障害が発生しやすくなります。たとえば「プレイヤー」と「マッチ履歴」は `1対n` の関係性にあります。仮にマッチ履歴が 10000 件あるプレイヤーデータを更新する場合、10000 件のマッチ履歴を更新する処理が同じトランザクション内で行われます。マッチ履歴の更新処理が一つでも失敗した場合、プレイヤーの更新処理も失敗するため、プレイヤーの更新ができなくなってしまいます。

これらの理由から集約はなるべく小さく区切ることが望ましいです。

#### 集約をどこで区切るか

大きな集約がもたらす問題を避けるためには、集約の範囲をどこで区切るかを考える必要があります。集約の範囲に迷った際には、2 つの基準を参考にしてみてください。

- **ルートエンティティに対して `1対n` の関係性にあるエンティティを保有する場合、保有数の上限が適切か**
- **強整合性（トランザクション整合性）が必要か**

> **Note:** ベストな集約の範囲を見つけるのは難しく、正解は複数あります。迷ったときはとりあえず実装してみるのも一つの手です。よくない集約は実装してみることで、扱いにくい、パフォーマンスが悪いなどの問題に気づきます。その結果を踏まえて集約の範囲を見直し、ブラッシュアップすることが大切です。

##### 1. ルートエンティティに対して `1対n` の関係性にあるエンティティを保有する場合、保有数の上限が適切か

ルートエンティティに対する関係性は重要な要素です。ルートエンティティと保有するエンティティの間の関係が `1対n` の場合、その `n` の数には上限があるかどうかによって同一集約に含めた方が良いかどうかが決まります。

たとえば、「プレイヤー」と「デッキ」の関係性は `1対1` ですが、デッキ内のユニット数には上限（例: 5体）があります。MAX でも 5 体程度であれば、「プレイヤー」と「デッキ」を同一集約に含めることによる問題よりも、集約によって整合性を確実に担保するメリットが勝ります。

```rust
impl Deck {
    pub fn add_unit(&mut self, unit_id: String) -> Result<(), String> {
        // ユニット数の上限のチェックを行い、整合性を保つことができる
        if self.unit_ids.len() >= self.max_size {
            return Err(format!("デッキには最大{}体までしか追加できません", self.max_size));
        }
        self.unit_ids.push(unit_id);
        Ok(())
    }
}
```

しかし、マッチ履歴など、数の上限が非常に大きい場合やそもそも上限が決められていない場合は、パフォーマンスやトランザクションのロックの問題が発生する可能性が高くなります。そのため、「プレイヤー」と「マッチ履歴」を別の集約にすることを検討する必要があります。

##### 2. 強整合性（トランザクション整合性）が必要か

集約の範囲を決定する際、もう一つの重要な考慮事項は強整合性、つまりトランザクション整合性の必要性です。すべてのデータが常に正確で最新の状態である必要がある場合、それらのデータは同じ集約内に含めるべきです。しかし、すべての場合において強い整合性が必要というわけではありません。

たとえば、「プレイヤー」と「達成実績」の関係で考えてみましょう。プレイヤー情報は、名前やレベルなど重要なビジネスデータを含んでおり、これらの情報の整合性は重要です。一方で、達成実績はプレイヤーの行動の履歴を記録するもので、プレイヤーの基本情報と直接的に関連するわけではありません。

また、仮に整合性が崩れ実績が正確に記録されないことがあったとしても、ビジネス的にクリティカルな問題にはならないため、許容するという判断も可能でしょう。

このように本当に強整合性が必要なのかどうかをいくつかの要素で判断することができます。強整合性の必要性が低い、または必要ない場合はデータを別の集約として扱い整合性の要求を緩和することが可能です。

### 集約間は識別子 (ID) で参照する

ここでは、「プレイヤー」と「マッチ履歴」を別の集約として扱ってみましょう。集約をそれぞれ実装すると以下のようになります。

```rust
pub struct Player {
    player_id: PlayerId,
    player_name: PlayerName,
    level: Level,
    deck: Deck,
}

pub struct MatchRecord {
    match_record_id: MatchRecordId,
    result: MatchResult,
    opponent_name: String,
    played_at: DateTime<Utc>,
}
```

しかし、これではマッチ履歴集約がどのプレイヤーに紐づくか（どのプレイヤーのマッチ履歴なのか）がわかりません。プレイヤーとマッチ履歴を関連付けるためには、マッチ履歴集約にプレイヤーとの関連性を持たせる必要があります。

**アンチパターン: 集約を直接保持する**

```rust
pub struct MatchRecord {
    match_record_id: MatchRecordId,
    result: MatchResult,
    opponent_name: String,
    played_at: DateTime<Utc>,
    player: Player,  // ❌ アンチパターン！
}

impl MatchRecord {
    // マッチ履歴集約からプレイヤー集約のメソッドを実行できてしまう
    pub fn anti_pattern_method(&mut self) {
        // プレイヤー集約の整合性を破壊できてしまう
        let new_name = PlayerName::new("不正な名前変更".to_string()).unwrap();
        self.player.change_name(new_name);
    }
}
```

これはアンチパターンです。集約が関連性を表現するために集約を保持してはいけません。なぜなら、マッチ履歴集約からプレイヤー集約のメソッドを実行できてしまい、せっかくプレイヤー集約内で保った整合性を破壊することが可能になってしまいます。整合性が破壊されることを防ぐにはプレイヤー集約とマッチ履歴集約を同一のトランザクション内で処理する必要があります。それは `1 集約 1 トランザクション`のルールに反します。

**正しいパターン: IDで参照する**

集約間は**識別子 (ID)** で参照することで解決されます。

```rust
pub struct MatchRecord {
    match_record_id: MatchRecordId,
    result: MatchResult,
    opponent_name: String,
    played_at: DateTime<Utc>,
    player_id: PlayerId,  // ✅ IDで参照
}
```

これでマッチ履歴集約が直接プレイヤー集約にアクセスすることができなくなりました。プレイヤー集約にアクセスするにはリポジトリに一度問い合わせなければいけません。ドメインオブジェクトでリポジトリは利用できないため、実質的にアクセスできないことを意味します。これは大きなメリットです。

これらの理由から集約間は識別子 (ID) で参照しなければなりません。

### 集約の外部では結果整合性を用いる

ここでも「プレイヤー」と「達成実績」を別の集約として扱ってみましょう。「プレイヤー」と「達成実績」には `1対n` の関係性があります。

たとえば、1 人のプレイヤーの達成実績の上限が 100 件だとします。「プレイヤー」と「達成実績」を別の集約として扱うということはそれぞれ別のトランザクションで更新するということです。つまり、整合性が崩れ 101 件目以降の達成実績が作成されてしまう可能性があることを意味します。集約を別にするということはこの挙動を許容するということです。

ですが仮に 101 件の達成実績が作成され、それがビジネス的にクリティカルな問題にはならないとしても、上限を 100 件と決めた理由があるでしょう。上限を超えた状態そのままで放置することは問題です。

このような場合に、**結果整合性**を用いることで整合性を担保することができます。結果整合性を簡単に説明すると、一時的にデータの不整合が起きても、最終的には整合性が担保されていれば OK という考え方です。

結果整合性を保つ方法として、たとえば毎日バッチ処理でプレイヤーの達成実績を監視し、数が 100 件を超えていた場合、101 件目以降の達成実績を無効にする処理を実行するという方法が考えられます。少し極端な例ですが、これによりアチーブメント数が結果的に 100 件以下になり、整合性が担保されます。

> **Note:** 集約を設計していると、本当に強整合性が必要なものは意外と少ないことに気づきます。本当に強整合性が必要なものだけ同一集約とし、それ以外は結果整合性を用いることを検討しましょう。そうすることで、小さな集約を設計することができます。

結果整合性を保つためにドメインイベントを活用することもあります。ドメインイベントについては後の章で説明します。

## Rustでの集約実装のポイント

### 1. 所有権を活用した整合性の保護

Rustの所有権システムにより、集約内部のエンティティへの直接アクセスを防ぐことができます。

```rust
pub struct Player {
    deck: Deck,  // privateフィールド: 外部からアクセス不可
}

impl Player {
    // 集約ルートを介した操作のみ提供
    pub fn add_unit_to_deck(&mut self, unit_id: String) -> Result<(), String> {
        self.deck.add_unit(unit_id)
    }
}
```

### 2. Result型によるビジネスルールの強制

集約内でのビジネスルール違反は `Result` 型で明示的にエラーを返します。

```rust
pub fn add_unit_to_deck(&mut self, unit_id: String) -> Result<(), String> {
    self.deck.add_unit(unit_id)
}
```

### 3. 借用によるデータの安全な公開

内部のデータを公開する際は借用を使用し、変更不可能な参照のみを提供します。

```rust
pub fn deck_unit_ids(&self) -> &[String] {
    self.deck.unit_ids()  // 借用で公開、変更不可
}
```

### 4. 型エイリアスの活用

集約間の参照には、具体的な型（IDの値オブジェクト）を使用します。

```rust
pub struct MatchRecord {
    player_id: PlayerId,  // 型安全なID参照
}
```

## まとめ

- **集約とは、関連するオブジェクト群を 1 つのユニットとして管理するための手法**
- **集約は、1 つのルートエンティティ（集約ルート）と、それに関連するエンティティや値オブジェクトで構成される**
- **集約はなるべく小さくすることで、パフォーマンスやトランザクションのロックの問題を回避する**
- **集約内は強整合性、集約間は結果整合性を用いる**
- **デメテルの法則に従い、集約内部への直接アクセスを防ぐ**
- **Rustの型システムと所有権を活用して、より安全な集約を実装できる**

本章では、集約の設計と実装について学びました。集約は DDD の中でも特に重要な概念で、適切に設計することでビジネスルールとデータの整合性を維持できます。次章では、集約や値オブジェクトで表現できないドメイン知識を扱うドメインサービスについて学んでいきます。
