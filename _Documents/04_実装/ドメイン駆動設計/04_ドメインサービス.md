# ドメインサービスの実装 (Rust版)

## ドメインサービスとは

ドメインサービス (Domain Service) とは、ドメインモデルの中で、エンティティや値オブジェクトだけでは自然に表現できないビジネスロジックをカプセル化するための「サービス」です。

### サービスとは

ここで、「サービス」について考えておきましょう。DDD ではサービスが 2 つ存在します。1 つが本章で紹介するドメインサービスで、もう一方がアプリケーションサービスです。混同しがちですが、それぞれ以下のような違いがあります。

| | ドメインサービス | アプリケーションサービス |
|---|---|---|
| 主な役割 | ビジネスロジックの実装 | ユースケースの実装 |
| 操作するもの | ドメインオブジェクト (集約) | ドメインサービス、ドメインオブジェクト (集約) |
| ビジネスルール | ドメイン固有のルールを実装 | ユースケース固有の手順を調整 |
| データの永続化 | 永続化責務は持たない | 永続化の責務を持つ |

ドメインサービスはアプリケーションサービスと比較して、ドメインに特化したサービスです。

### 不自然なドメインの振る舞い

エンティティや値オブジェクトだけでは自然に表現できないビジネスロジックとは何でしょうか？

たとえば、プレイヤーエンティティの識別子 (ID) は UUID であり、異なるプレイヤー間で重複することはありません。つまり、同一プレイヤー名で複数のプレイヤーを登録することはできません。これはビジネスルールであり、このルールを守るためにプレイヤーを登録する際には、すでに登録されているプレイヤー名かどうかドメインオブジェクトで確認する必要があります。

それでは、このルールをプレイヤーエンティティに実装してみましょう。

```rust
impl Player {
    // プレイヤー自身が名前の重複チェックを行う
    pub fn is_duplicate_name(&self, name: &PlayerName) -> bool {
        // 既に登録されているプレイヤー名かどうかを確認する処理
        // ここでデータベースに問い合わせる必要がある...？
        false
    }
}

// 使用例
let player_name = PlayerName::new("迅悠一".to_string()).unwrap();
let deck_name = DeckName::new("テストデッキ".to_string()).unwrap();
let player = Player::create(player_name.clone(), deck_name);

// プレイヤー自身が名前の重複チェックを行う
let is_duplicate = player.is_duplicate_name(&player_name);
```

プレイヤー自身がプレイヤー名の重複チェックを行っていますが、自身の一意性（重複のないこと）を自身でチェックすることは、ドメインモデルの観点から見ると不自然です。

通常、エンティティの一意性は外部のコンテキスト（たとえば、データベースやリポジトリ）によって管理されるべきです。エンティティ自身が自分の一意性を管理することは、役割と責任の観点から見ても不自然です。

## プレイヤー名重複チェックドメインサービスの実装

このような不自然さを解消するために、ドメインサービスを利用します。それでは、プレイヤー名の重複チェックを行うドメインサービスを実装してみましょう。

### ドメインサービスの実装

```rust
// domain/player_management/services/player_name_duplication_check_domain_service.rs

use crate::domain::player_management::models::player::player_name::player_name::PlayerName;

/// プレイヤー名重複チェックドメインサービス
/// プレイヤー名が既に登録されているかどうかをチェックする
pub struct PlayerNameDuplicationCheckDomainService {
    // 将来的にはリポジトリへの依存を持つ
}

impl PlayerNameDuplicationCheckDomainService {
    pub fn new() -> Self {
        Self {}
    }

    /// プレイヤー名の重複をチェック
    /// 
    /// # Arguments
    /// * `player_name` - チェック対象のプレイヤー名
    /// 
    /// # Returns
    /// * `Ok(true)` - 重複している
    /// * `Ok(false)` - 重複していない
    pub async fn execute(&self, player_name: &PlayerName) -> Result<bool, String> {
        // 本来は、データベースに問い合わせて重複があるか確認する
        // この章では省略し、次章（リポジトリ）で実装する
        let is_duplicate = false;

        Ok(is_duplicate)
    }
}
```

> **Note:** ドメインサービスの命名は、そのドメインで表現したい概念に基づいて行います。ここではプレイヤー名の重複チェックを行うドメインサービスなので、`PlayerNameDuplicationCheckDomainService` という名前にしました。アプリケーションサービスと混同させないために、ドメインサービスの命名規則は `[処理名]DomainService` とするのがオススメです。

### ドメインサービスの利用

それでは重複のチェックにこのドメインサービスを利用するように変更します。

```rust
use crate::domain::player_management::models::player::{Player, PlayerName, DeckName};
use crate::domain::player_management::services::PlayerNameDuplicationCheckDomainService;

async fn register_player() -> Result<(), String> {
    let player_name = PlayerName::new("迅悠一".to_string())?;
    let deck_name = DeckName::new("テストデッキ".to_string())?;

    // ドメインサービスを使って重複チェック
    let duplication_check_service = PlayerNameDuplicationCheckDomainService::new();
    let is_duplicate = duplication_check_service.execute(&player_name).await?;

    if is_duplicate {
        return Err("このプレイヤー名は既に登録されています".to_string());
    }

    let player = Player::create(player_name, deck_name);
    
    // プレイヤーを保存する処理...
    
    Ok(())
}
```

`PlayerNameDuplicationCheckDomainService` を利用することで、プレイヤー自身に重複かどうか問い合わせをしていた不自然さを解消することができました。このように、エンティティや値オブジェクトだけでは自然に表現できないロジックはドメインサービスに実装することで、ドメインモデルをより自然な形で表現することができます。

## ドメインモデル貧血症

ドメインサービスを利用することで柔軟にドメインモデルを表現することができますが、ドメインサービスを過剰に利用するとドメインモデル貧血症になってしまう可能性があります。ドメインモデル貧血症とは、ドメインモデルがドメインサービスに依存しすぎてしまい、ドメインモデル自身が何も語らなくなってしまう状態を指します。

たとえば、エンティティには属性を変更するメソッドがあります。これはドメインサービスを利用することでも実現できます。

**ドメインサービスを利用する前の例:**

```rust
pub struct Player {
    player_id: PlayerId,
    player_name: PlayerName,
    level: Level,
}

impl Player {
    pub fn change_name(&mut self, new_name: PlayerName) -> Result<(), String> {
        // プレイヤー名変更時のバリデーション
        if new_name.value().is_empty() {
            return Err("プレイヤー名は空にできません".to_string());
        }
        self.player_name = new_name;
        Ok(())
    }
}
```

**ドメインサービスを過剰に利用した例 (アンチパターン):**

```rust
pub struct Player {
    player_id: PlayerId,
    pub player_name: PlayerName,  // publicフィールド
    level: Level,
}

pub struct PlayerNameChangeDomainService;

impl PlayerNameChangeDomainService {
    pub fn execute(player: &mut Player, new_name: PlayerName) -> Result<(), String> {
        // プレイヤー名変更時のバリデーション
        if new_name.value().is_empty() {
            return Err("プレイヤー名は空にできません".to_string());
        }
        player.player_name = new_name;
        Ok(())
    }
}
```

しかし、ドメインサービスを過剰に利用した例の `Player` エンティティを見てみると、ただのデータを保持しただけの構造体で、どのようなビジネスルールがあるのか読み取れなくなってしまいました。ドメインの表現は、ドメインモデル貧血症にならないように、まずはエンティティや値オブジェクトで実装できないか検討し、それでも表現できない場合にのみドメインサービスを利用するようにしましょう。

## ドメインサービスを利用する基準

> **エンティティや値オブジェクトだけでは自然に表現できない**

ドメインサービスを利用する基準を上記のように定義しましたが、より具体的にはどのような場合にドメインサービスを利用するのが適切なのでしょうか？具体例としては、以下のような場合です。

- **複数集約をまたいだ処理が必要な場合**
- **データベースへの問い合わせが必要な場合**

それぞれ説明します。

### 複数集約をまたいだ処理が必要な場合

ドメインモデル内の複数の集約間でビジネスロジックを実行する必要がある場合、ドメインサービスを利用します。各集約はそれ自体で一貫性を持ちますが、複数の集約間で一貫性を保つための操作は、それぞれの集約の範囲を超えるため、集約の外部で行われるべきです。

たとえば、「マッチング」と「ゲーム」が別集約で、マッチングの参加人数に上限がある場合、マッチングへの参加時に参加人数が上限に達していないかを確認する必要があります。このような場合、マッチングの集約内でゲーム数を管理するのではなく、ドメインサービスを利用して参加人数を取得し、上限チェックを行うことができます。

```rust
pub struct MatchingCapacityCheckDomainService;

impl MatchingCapacityCheckDomainService {
    /// マッチングの参加可能人数をチェック
    pub async fn can_join(
        &self,
        matching: &Matching,
        current_participants: usize,
    ) -> Result<bool, String> {
        let max_capacity = matching.max_participants();
        
        if current_participants >= max_capacity {
            return Ok(false);
        }
        
        Ok(true)
    }
}
```

### データベースへの問い合わせが必要な場合

エンティティや値オブジェクトでは表現できない、データベースへの問い合わせが必要なビジネスロジックもドメインサービスで実装されます。エンティティや値オブジェクトは、通常、自身の状態を保持し、その状態に基づいてビジネスロジックを実行します。

しかし、データベースからのデータ取得や集計など、外部リソースに依存する操作は、エンティティや値オブジェクトの範囲を超えるため、ドメインサービスを通じて行われるべきです。たとえば、重複チェックなどはその典型的な例です。

## 実装例: マッチング関連のドメインサービス

ゲームシステムでよく使用されるドメインサービスの例をいくつか示します。

### 1. マッチング成立チェックドメインサービス

```rust
// domain/matching_management/services/matching_establishment_check_domain_service.rs

use crate::domain::matching_management::models::matching::Matching;

pub struct MatchingEstablishmentCheckDomainService;

impl MatchingEstablishmentCheckDomainService {
    /// マッチングが成立可能かチェック
    /// 
    /// ビジネスルール:
    /// - 参加者が2人以上
    /// - 全参加者が準備完了状態
    pub fn can_establish(&self, matching: &Matching) -> Result<bool, String> {
        let participant_count = matching.participant_count();
        
        if participant_count < 2 {
            return Ok(false);
        }
        
        // 本来はリポジトリで全参加者の準備状態を確認
        // ここでは簡略化
        Ok(true)
    }
}
```

### 2. ユニット配置検証ドメインサービス

```rust
// domain/unit_management/services/unit_placement_validation_domain_service.rs

use crate::domain::unit_management::models::unit::Unit;

pub struct UnitPlacementValidationDomainService;

impl UnitPlacementValidationDomainService {
    /// ユニットの配置が有効かどうかをチェック
    /// 
    /// ビジネスルール:
    /// - 配置位置が有効範囲内
    /// - 他のユニットと重複していない
    /// - チームの配置可能数を超えていない
    pub fn validate_placement(
        &self,
        unit: &Unit,
        position: (i32, i32),
        existing_positions: &[(i32, i32)],
    ) -> Result<(), String> {
        // 範囲チェック
        if position.0 < 0 || position.0 >= 10 || position.1 < 0 || position.1 >= 10 {
            return Err("配置位置が範囲外です".to_string());
        }
        
        // 重複チェック
        if existing_positions.contains(&position) {
            return Err("既に他のユニットが配置されています".to_string());
        }
        
        Ok(())
    }
}
```

## Rustでのドメインサービス実装のポイント

### 1. トレイトを使った抽象化

テスタビリティを向上させるため、トレイトを使ってドメインサービスを抽象化できます。

```rust
// トレイトで抽象化
pub trait PlayerNameDuplicationChecker {
    async fn is_duplicate(&self, name: &PlayerName) -> Result<bool, String>;
}

// 実装
pub struct PlayerNameDuplicationCheckDomainService {
    // リポジトリへの依存など
}

impl PlayerNameDuplicationChecker for PlayerNameDuplicationCheckDomainService {
    async fn is_duplicate(&self, name: &PlayerName) -> Result<bool, String> {
        // 実装
        Ok(false)
    }
}
```

### 2. Result型によるエラーハンドリング

ドメインサービスの操作結果は `Result` 型で返します。

```rust
pub async fn execute(&self, player_name: &PlayerName) -> Result<bool, String> {
    // エラーが発生する可能性のある処理
    Ok(true)
}
```

### 3. 依存性注入

リポジトリなどの依存をコンストラクタで受け取ることで、テストしやすくなります。

```rust
pub struct PlayerNameDuplicationCheckDomainService<R>
where
    R: PlayerRepository,
{
    player_repository: R,
}

impl<R> PlayerNameDuplicationCheckDomainService<R>
where
    R: PlayerRepository,
{
    pub fn new(player_repository: R) -> Self {
        Self { player_repository }
    }

    pub async fn execute(&self, player_name: &PlayerName) -> Result<bool, String> {
        self.player_repository
            .find_by_name(player_name)
            .await
            .map(|result| result.is_some())
    }
}
```

### 4. 状態を持たない

ドメインサービスは基本的に状態を持たず、引数で受け取った情報のみで処理を行います。

```rust
// Good: 状態を持たない
pub struct OrderValidationDomainService;

impl OrderValidationDomainService {
    pub fn validate(&self, order: &Order) -> Result<(), String> {
        // 引数の情報のみで処理
        Ok(())
    }
}

// Bad: 状態を持つ（避けるべき）
pub struct OrderValidationDomainService {
    validation_count: u32,  // ❌ 状態を持っている
}
```

## まとめ

- **ドメインサービスとアプリケーションサービスは似ているが、それぞれ別の役割を持つ**
- **エンティティや値オブジェクトだけでは自然に表現できないビジネスロジックはドメインサービスに実装する**
- **ドメインモデル貧血症にならないように、まずはドメインオブジェクトで実装できないか検討する**
- **ドメインサービスは複数集約をまたぐ処理やDB問い合わせが必要な場合に使用する**
- **Rustではトレイト、Result型、依存性注入を活用してテスタブルなドメインサービスを実装できる**

本章では、ドメインサービスについて学びました。ドメインサービスはドメインモデルの設計を単純化するために利用されます。ドメインモデルの設計において、ドメインサービスを利用するかどうかは、ドメインモデルの表現を自然にするために重要です。

次章では、リポジトリについて学び、`PlayerNameDuplicationCheckDomainService` にリポジトリを適用します。
