# ゲームステートの分離

## 推奨設計パターン

### 1. **Screen/State分離パターン**

各ゲームステートを独立した画面コンポーネントに分割します。

````typescript
export type GameState = 
  | { type: 'MENU' }
  | { type: 'BATTLE'; playerHp: number; enemyHp: number }
  | { type: 'RESULT'; winner: 'player' | 'enemy' };

export type GameAction = 
  | { type: 'START_BATTLE' }
  | { type: 'ATTACK' }
  | { type: 'END_BATTLE'; winner: 'player' | 'enemy' }
  | { type: 'BACK_TO_MENU' };
````

### 2. **Reducer + Context パターン**

ロジックとUIを明確に分離します。

````typescript
import { useReducer, useCallback } from 'react';

const initialState: GameState = { type: 'MENU' };

function gameReducer(state: GameState, action: GameAction): GameState {
  switch (state.type) {
    case 'MENU':
      if (action.type === 'START_BATTLE') {
        return { type: 'BATTLE', playerHp: 100, enemyHp: 100 };
      }
      return state;

    case 'BATTLE':
      if (action.type === 'ATTACK') {
        const newPlayerHp = state.playerHp - Math.floor(Math.random() * 20);
        const newEnemyHp = state.enemyHp - Math.floor(Math.random() * 25);
        
        if (newEnemyHp <= 0) {
          return { type: 'RESULT', winner: 'player' };
        }
        if (newPlayerHp <= 0) {
          return { type: 'RESULT', winner: 'enemy' };
        }
        
        return { ...state, playerHp: newPlayerHp, enemyHp: newEnemyHp };
      }
      return state;

    case 'RESULT':
      if (action.type === 'BACK_TO_MENU') {
        return { type: 'MENU' };
      }
      return state;

    default:
      return state;
  }
}

export function useGameState() {
  const [state, dispatch] = useReducer(gameReducer, initialState);

  const handleScreenTap = useCallback((x: number, y: number) => {
    // ステート別にタップを処理
    switch (state.type) {
      case 'MENU':
        dispatch({ type: 'START_BATTLE' });
        break;
      case 'BATTLE':
        dispatch({ type: 'ATTACK' });
        break;
      case 'RESULT':
        dispatch({ type: 'BACK_TO_MENU' });
        break;
    }
  }, [state.type]);

  return { state, dispatch, handleScreenTap };
}
````

### 3. **各ステートの画面コンポーネント**

````typescript
import React from 'react';

interface MenuScreenProps {
  onTap: () => void;
}

export const MenuScreen: React.FC<MenuScreenProps> = ({ onTap }) => {
  return (
    <div className="menu-screen" onClick={onTap}>
      <h1>ワールドトリガー</h1>
      <button>バトル開始</button>
    </div>
  );
};
````

````typescript
import React from 'react';

interface BattleScreenProps {
  playerHp: number;
  enemyHp: number;
  onTap: () => void;
}

export const BattleScreen: React.FC<BattleScreenProps> = ({ 
  playerHp, 
  enemyHp, 
  onTap 
}) => {
  return (
    <div className="battle-screen" onClick={onTap}>
      <div className="character-display">
        <div className="player">
          <p>プレイヤー</p>
          <div className="hp-bar">
            <div className="hp" style={{ width: `${playerHp}%` }} />
          </div>
          <p>{playerHp} HP</p>
        </div>
        
        <div className="enemy">
          <p>敵</p>
          <div className="hp-bar">
            <div className="hp" style={{ width: `${enemyHp}%` }} />
          </div>
          <p>{enemyHp} HP</p>
        </div>
      </div>
      
      <button>攻撃</button>
    </div>
  );
};
````

````typescript
import React from 'react';

interface ResultScreenProps {
  winner: 'player' | 'enemy';
  onTap: () => void;
}

export const ResultScreen: React.FC<ResultScreenProps> = ({ winner, onTap }) => {
  return (
    <div className="result-screen" onClick={onTap}>
      <h2>{winner === 'player' ? '勝利！' : '敗北...'}</h2>
      <button>メニューに戻る</button>
    </div>
  );
};
````

### 4. **メインアプリケーション**

````typescript
import React from 'react';
import { useGameState } from './hooks/useGameState';
import { MenuScreen } from './screens/MenuScreen';
import { BattleScreen } from './screens/BattleScreen';
import { ResultScreen } from './screens/ResultScreen';
import './App.css';

function App() {
  const { state, handleScreenTap } = useGameState();

  const renderScreen = () => {
    switch (state.type) {
      case 'MENU':
        return <MenuScreen onTap={handleScreenTap} />;
      
      case 'BATTLE':
        return (
          <BattleScreen 
            playerHp={state.playerHp}
            enemyHp={state.enemyHp}
            onTap={handleScreenTap}
          />
        );
      
      case 'RESULT':
        return (
          <ResultScreen 
            winner={state.winner}
            onTap={handleScreenTap}
          />
        );
    }
  };

  return (
    <div className="game-container">
      {renderScreen()}
    </div>
  );
}

export default App;
````

## このパターンのメリット

✅ **型安全**: TypeScriptの型チェックで予期しないステーション遷移を防止  
✅ **関心事の分離**: 各画面の処理ロジックが独立  
✅ **テスト容易**: Reducerを独立してテスト可能  
✅ **スケーラブル**: 新しいステートを追加する際の影響が最小限  

わかりやすい具体例になっていますでしょうか？
