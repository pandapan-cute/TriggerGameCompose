# アプリケーションサービスの実装 (Rust版)

## アプリケーションサービスとは

アプリケーションサービス (Application Service) とは、ドメインサービスに次ぐ 2 つ目のサービスで、ユースケースを実現するための操作を提供するサービスです。アプリケーションサービスは、ドメイン層の「エンティティ」「値オブジェクト」「ドメインサービス」などのドメインオブジェクトを利用してユースケースを実現します。

「ユースケース」とは、ユーザーがシステムを利用する際に実現したい機能や処理のことです。たとえば、プレイヤー管理コンテキストでは、

- プレイヤーを登録する
- プレイヤーを取得する
- プレイヤー名を変更する
- プレイヤーを削除する

などの、いわゆるCRUD操作がユースケースにあたります。

では、それぞれのユースケースを表現するアプリケーションサービスを実装していきましょう。

## プレイヤー登録アプリケーションサービスの実装

それでは、「プレイヤーを登録する」ユースケースを実現するアプリケーションサービスを実装していきましょう。`application`ディレクトリ配下に`player_management/register_player_application_service.rs`ファイルを作成します。

```rust
// application/player_management/register_player_application_service.rs

use crate::domain::player_management::models::player::{Player, PlayerName, DeckName};
use crate::domain::player_management::repositories::player_repository::PlayerRepository;
use crate::domain::player_management::services::player_name_duplication_check_domain_service::PlayerNameDuplicationCheckDomainService;
use std::sync::Arc;

/// プレイヤー登録コマンド
#[derive(Debug, Clone)]
pub struct RegisterPlayerCommand {
    pub player_name: String,
    pub deck_name: String,
}

/// プレイヤー登録アプリケーションサービス
pub struct RegisterPlayerApplicationService<R>
where
    R: PlayerRepository,
{
    player_repository: Arc<R>,
}

impl<R> RegisterPlayerApplicationService<R>
where
    R: PlayerRepository,
{
    pub fn new(player_repository: Arc<R>) -> Self {
        Self { player_repository }
    }

    pub async fn execute(&self, command: RegisterPlayerCommand) -> Result<String, String> {
        // プレイヤー名の重複チェック
        let player_name = PlayerName::new(command.player_name)?;
        let duplication_check = PlayerNameDuplicationCheckDomainService::new(
            Arc::clone(&self.player_repository)
        );
        
        let is_duplicate = duplication_check.execute(&player_name).await?;
        if is_duplicate {
            return Err("既に存在するプレイヤー名です".to_string());
        }

        // プレイヤーを作成
        let deck_name = DeckName::new(command.deck_name)?;
        let player = Player::create(player_name, deck_name);

        // プレイヤーを保存
        self.player_repository.save(&player).await?;

        Ok(player.player_id().value().to_string())
    }
}
```

`RegisterPlayerApplicationService`では、まず`PlayerNameDuplicationCheckDomainService`を利用して、プレイヤー名の重複チェックを行います。重複している場合は、`Err`を返します。重複していない場合は、`Player`エンティティを生成し、`PlayerRepository`を利用して永続化します。

ここで重要なのは、プレイヤー名の重複チェックのビジネスロジックや、`Player`エンティティ生成時のビジネスロジックがドメインオブジェクトに隠蔽されているということです。これにより、アプリケーションサービスの実装はドメイン知識を持たない状態で、ドメインオブジェクトを利用するだけでユースケースを実現することができます。

### プレイヤー登録アプリケーションサービスのテスト

それでは、テストを実装していきましょう。

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::infrastructure::in_memory::player_in_memory_repository::InMemoryPlayerRepository;

    #[tokio::test]
    async fn test_register_player_success() {
        let repository = Arc::new(InMemoryPlayerRepository::new());
        let service = RegisterPlayerApplicationService::new(repository.clone());

        let command = RegisterPlayerCommand {
            player_name: "迅悠一".to_string(),
            deck_name: "攻撃型デッキ".to_string(),
        };

        let result = service.execute(command).await;
        assert!(result.is_ok());

        let player_id = result.unwrap();
        assert!(!player_id.is_empty());
    }

    #[tokio::test]
    async fn test_register_player_duplicate_name() {
        let repository = Arc::new(InMemoryPlayerRepository::new());
        let service = RegisterPlayerApplicationService::new(repository.clone());

        // 最初のプレイヤーを登録
        let command = RegisterPlayerCommand {
            player_name: "迅悠一".to_string(),
            deck_name: "攻撃型デッキ".to_string(),
        };
        service.execute(command.clone()).await.unwrap();

        // 同じ名前で再度登録を試みる
        let result = service.execute(command).await;
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "既に存在するプレイヤー名です");
    }

    #[tokio::test]
    async fn test_register_player_invalid_name() {
        let repository = Arc::new(InMemoryPlayerRepository::new());
        let service = RegisterPlayerApplicationService::new(repository);

        let command = RegisterPlayerCommand {
            player_name: "".to_string(), // 空文字列は不正
            deck_name: "攻撃型デッキ".to_string(),
        };

        let result = service.execute(command).await;
        assert!(result.is_err());
    }
}
```

このテストでは、テスト用のインメモリリポジトリを利用し、`RegisterPlayerApplicationService`をインスタンス化し、実行してプレイヤーが正常に作成できることを確認しています。また、重複プレイヤー名が存在する場合はエラーが返されることを確認しています。

アプリケーションサービスのテストでは、値に関する検証を行っていません。その理由は、値に対する検証はドメインオブジェクトのテストですでに行っているからです。このアプローチにより、アプリケーションサービスのテストはユースケースに集中することができます。その結果テストは、よりシンプルで理解しやすくなります。

## プレイヤー取得アプリケーションサービスの実装

次は、「プレイヤーを取得する」ユースケースを実現するアプリケーションサービスを実装していきましょう。

```rust
// application/player_management/get_player_application_service.rs

use crate::domain::player_management::models::player::{Player, PlayerId};
use crate::domain::player_management::repositories::player_repository::PlayerRepository;
use std::sync::Arc;

/// プレイヤー取得アプリケーションサービス
pub struct GetPlayerApplicationService<R>
where
    R: PlayerRepository,
{
    player_repository: Arc<R>,
}

impl<R> GetPlayerApplicationService<R>
where
    R: PlayerRepository,
{
    pub fn new(player_repository: Arc<R>) -> Self {
        Self { player_repository }
    }

    pub async fn execute(&self, player_id: &str) -> Result<Option<Player>, String> {
        let player_id = PlayerId::from_string(player_id.to_string());
        let player = self.player_repository.find_by_id(&player_id).await?;

        Ok(player)
    }
}
```

`GetPlayerApplicationService`では、`PlayerRepository`を利用して`Player`エンティティを取得し、`Player`エンティティをそのまま返却しています。

この実装には問題があります。ドメインオブジェクトのクライアントはアプリケーションサービスです。現在の実装ではPlayer集約をそのまま返却しています。これでは、アプリケーションサービスのクライアントであるプレゼンテーション層にドメインオブジェクトが漏れてしまい、プレゼンテーション層でドメインオブジェクトを操作できてしまいます。ドメインオブジェクトに依存するレイヤーが増えると、ドメインオブジェクトの変更が困難になります。

この問題にDTO (Data Transfer Object) を利用することで対応します。

### DTO (Data Transfer Object)

DTOとはデザインパターンの一つで、一般的には関連データをまとめて転送するためのデータ構造です。ドメイン駆動設計においてはドメインオブジェクトのデータのみをプレゼンテーション層に渡すためのデータ構造と定義することができます。

まずは DTO を作成していきましょう。

```rust
// application/player_management/player_dto.rs

use crate::domain::player_management::models::player::Player;
use serde::{Deserialize, Serialize};

/// プレイヤーDTO
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct PlayerDTO {
    pub player_id: String,
    pub player_name: String,
    pub level: u32,
    pub deck_id: String,
    pub deck_name: String,
    pub deck_unit_count: usize,
    pub deck_unit_ids: Vec<String>,
}

impl PlayerDTO {
    /// PlayerエンティティからDTOを生成
    pub fn from_player(player: &Player) -> Self {
        Self {
            player_id: player.player_id().value().to_string(),
            player_name: player.player_name().value().to_string(),
            level: player.level().value(),
            deck_id: player.deck_id().value().to_string(),
            deck_name: player.deck_name().value().to_string(),
            deck_unit_count: player.deck_unit_count(),
            deck_unit_ids: player.deck_unit_ids().to_vec(),
        }
    }
}
```

実装自体は非常にシンプルで、`Player`エンティティを受け取り、フィールドに値をセットします。これはただのデータを保持するための構造体です。しかし、この構造体には重要な役割があります。それは、ドメインオブジェクトをプレゼンテーション層に渡すためのデータ構造としての役割です。この構造体を利用することで、プレゼンテーション層はドメインオブジェクトを知ることなく、データのみを利用できるようになります。

`GetPlayerApplicationService`を修正し、`PlayerDTO`を返却するように実装しましょう。

```rust
// application/player_management/get_player_application_service.rs

use crate::application::player_management::player_dto::PlayerDTO;
use crate::domain::player_management::models::player::PlayerId;
use crate::domain::player_management::repositories::player_repository::PlayerRepository;
use std::sync::Arc;

pub struct GetPlayerApplicationService<R>
where
    R: PlayerRepository,
{
    player_repository: Arc<R>,
}

impl<R> GetPlayerApplicationService<R>
where
    R: PlayerRepository,
{
    pub fn new(player_repository: Arc<R>) -> Self {
        Self { player_repository }
    }

    pub async fn execute(&self, player_id: &str) -> Result<Option<PlayerDTO>, String> {
        let player_id = PlayerId::from_string(player_id.to_string());
        let player = self.player_repository.find_by_id(&player_id).await?;

        Ok(player.map(|p| PlayerDTO::from_player(&p)))
    }
}
```

これで、`GetPlayerApplicationService`は`PlayerDTO`を返却するようになり、ドメインオブジェクトがアプリケーション層から漏れ出すことを防ぐことができます。

### プレイヤー取得アプリケーションサービスのテスト

それでは、テストを実装していきましょう。

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::player_management::models::player::{Player, PlayerName, DeckName};
    use crate::infrastructure::in_memory::player_in_memory_repository::InMemoryPlayerRepository;

    #[tokio::test]
    async fn test_get_player_found() {
        let repository = Arc::new(InMemoryPlayerRepository::new());
        let service = GetPlayerApplicationService::new(repository.clone());

        // テストデータを作成
        let player_name = PlayerName::new("迅悠一".to_string()).unwrap();
        let deck_name = DeckName::new("攻撃型デッキ".to_string()).unwrap();
        let player = Player::create(player_name, deck_name);
        let player_id = player.player_id().value().to_string();

        repository.save(&player).await.unwrap();

        // プレイヤーを取得
        let result = service.execute(&player_id).await.unwrap();
        assert!(result.is_some());

        let dto = result.unwrap();
        assert_eq!(dto.player_id, player_id);
        assert_eq!(dto.player_name, "迅悠一");
    }

    #[tokio::test]
    async fn test_get_player_not_found() {
        let repository = Arc::new(InMemoryPlayerRepository::new());
        let service = GetPlayerApplicationService::new(repository);

        let result = service.execute("non-existent-id").await.unwrap();
        assert!(result.is_none());
    }
}
```

このテストでは、`GetPlayerApplicationService`を利用して、指定されたIDのプレイヤーが存在する場合は`PlayerDTO`に詰め替えられ、取得できることを確認しています。また、指定されたIDのプレイヤーが存在しない場合は`None`が取得できることを確認しています。

## プレイヤー名変更アプリケーションサービスの実装

次は、「プレイヤー名を変更する」ユースケースを実現するアプリケーションサービスを実装していきましょう。

```rust
// application/player_management/change_player_name_application_service.rs

use crate::domain::player_management::models::player::{PlayerId, PlayerName};
use crate::domain::player_management::repositories::player_repository::PlayerRepository;
use crate::domain::player_management::services::player_name_duplication_check_domain_service::PlayerNameDuplicationCheckDomainService;
use std::sync::Arc;

/// プレイヤー名変更コマンド
#[derive(Debug, Clone)]
pub struct ChangePlayerNameCommand {
    pub player_id: String,
    pub new_player_name: String,
}

/// プレイヤー名変更アプリケーションサービス
pub struct ChangePlayerNameApplicationService<R>
where
    R: PlayerRepository,
{
    player_repository: Arc<R>,
}

impl<R> ChangePlayerNameApplicationService<R>
where
    R: PlayerRepository,
{
    pub fn new(player_repository: Arc<R>) -> Self {
        Self { player_repository }
    }

    pub async fn execute(&self, command: ChangePlayerNameCommand) -> Result<(), String> {
        // プレイヤーを取得
        let player_id = PlayerId::from_string(command.player_id);
        let mut player = self.player_repository
            .find_by_id(&player_id)
            .await?
            .ok_or("プレイヤーが存在しません".to_string())?;

        // 新しいプレイヤー名の重複チェック
        let new_name = PlayerName::new(command.new_player_name)?;
        let duplication_check = PlayerNameDuplicationCheckDomainService::new(
            Arc::clone(&self.player_repository)
        );
        
        let is_duplicate = duplication_check.execute(&new_name).await?;
        if is_duplicate {
            return Err("既に存在するプレイヤー名です".to_string());
        }

        // プレイヤー名を変更
        player.change_name(new_name);

        // プレイヤーを更新
        self.player_repository.update(&player).await?;

        Ok(())
    }
}
```

`ChangePlayerNameApplicationService`では、`PlayerRepository`を利用して`Player`エンティティを一度取得します。その後、`Player`エンティティの`change_name`メソッドを利用してプレイヤー名を変更します。最後に、`PlayerRepository`を利用して永続化します。

更新系のアプリケーションサービスで特徴的なのが、一度リポジトリから`Player`エンティティを取得し、その後に`change_name`メソッドを利用してプレイヤー名を変更している点です。これは、`Player`エンティティの`change_name`メソッドが、プレイヤー名を変更するために必要なビジネスロジックを持っているためです。このような実装にすることで、プレイヤー名の変更に関するドメイン知識がドメイン層に集約され、アプリケーションサービスの実装はドメイン知識を持たずにユースケースを実現できます。

### プレイヤー名変更アプリケーションサービスのテスト

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::player_management::models::player::{Player, PlayerName, DeckName};
    use crate::infrastructure::in_memory::player_in_memory_repository::InMemoryPlayerRepository;

    #[tokio::test]
    async fn test_change_player_name_success() {
        let repository = Arc::new(InMemoryPlayerRepository::new());
        let service = ChangePlayerNameApplicationService::new(repository.clone());

        // テストデータを作成
        let player_name = PlayerName::new("迅悠一".to_string()).unwrap();
        let deck_name = DeckName::new("攻撃型デッキ".to_string()).unwrap();
        let player = Player::create(player_name, deck_name);
        let player_id = player.player_id().value().to_string();

        repository.save(&player).await.unwrap();

        // プレイヤー名を変更
        let command = ChangePlayerNameCommand {
            player_id: player_id.clone(),
            new_player_name: "迅".to_string(),
        };

        let result = service.execute(command).await;
        assert!(result.is_ok());

        // 変更が反映されているか確認
        let updated_player = repository
            .find_by_id(&PlayerId::from_string(player_id))
            .await
            .unwrap()
            .unwrap();
        assert_eq!(updated_player.player_name().value(), "迅");
    }

    #[tokio::test]
    async fn test_change_player_name_not_found() {
        let repository = Arc::new(InMemoryPlayerRepository::new());
        let service = ChangePlayerNameApplicationService::new(repository);

        let command = ChangePlayerNameCommand {
            player_id: "non-existent-id".to_string(),
            new_player_name: "新しい名前".to_string(),
        };

        let result = service.execute(command).await;
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "プレイヤーが存在しません");
    }

    #[tokio::test]
    async fn test_change_player_name_duplicate() {
        let repository = Arc::new(InMemoryPlayerRepository::new());
        let service = ChangePlayerNameApplicationService::new(repository.clone());

        // 2人のプレイヤーを作成
        let player1 = Player::create(
            PlayerName::new("迅悠一".to_string()).unwrap(),
            DeckName::new("デッキ1".to_string()).unwrap(),
        );
        let player2 = Player::create(
            PlayerName::new("三雲修".to_string()).unwrap(),
            DeckName::new("デッキ2".to_string()).unwrap(),
        );

        repository.save(&player1).await.unwrap();
        repository.save(&player2).await.unwrap();

        // player2の名前をplayer1と同じにしようとする
        let command = ChangePlayerNameCommand {
            player_id: player2.player_id().value().to_string(),
            new_player_name: "迅悠一".to_string(),
        };

        let result = service.execute(command).await;
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "既に存在するプレイヤー名です");
    }
}
```

## プレイヤー削除アプリケーションサービスの実装

最後は、「プレイヤーを削除する」ユースケースを実現するアプリケーションサービスを実装していきましょう。

```rust
// application/player_management/delete_player_application_service.rs

use crate::domain::player_management::models::player::PlayerId;
use crate::domain::player_management::repositories::player_repository::PlayerRepository;
use std::sync::Arc;

/// プレイヤー削除コマンド
#[derive(Debug, Clone)]
pub struct DeletePlayerCommand {
    pub player_id: String,
}

/// プレイヤー削除アプリケーションサービス
pub struct DeletePlayerApplicationService<R>
where
    R: PlayerRepository,
{
    player_repository: Arc<R>,
}

impl<R> DeletePlayerApplicationService<R>
where
    R: PlayerRepository,
{
    pub fn new(player_repository: Arc<R>) -> Self {
        Self { player_repository }
    }

    pub async fn execute(&self, command: DeletePlayerCommand) -> Result<(), String> {
        // プレイヤーを取得
        let player_id = PlayerId::from_string(command.player_id);
        let player = self.player_repository
            .find_by_id(&player_id)
            .await?
            .ok_or("プレイヤーが存在しません".to_string())?;

        // プレイヤーを削除（削除可能かのビジネスロジックをチェック）
        player.can_delete()?;

        // プレイヤーを削除
        self.player_repository.delete(&player_id).await?;

        Ok(())
    }
}
```

`DeletePlayerApplicationService`では、`PlayerRepository`を利用して`Player`エンティティを一度取得します。その後、`Player`エンティティの`can_delete`メソッドを利用してプレイヤー削除時の処理を行います。ここでは、プレイヤー削除可能かどうかの判定を`Player`エンティティの`can_delete`メソッド内で行っています。最後に、`PlayerRepository`を利用して永続化します。

### プレイヤー削除アプリケーションサービスのテスト

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::player_management::models::player::{Player, PlayerName, DeckName};
    use crate::infrastructure::in_memory::player_in_memory_repository::InMemoryPlayerRepository;

    #[tokio::test]
    async fn test_delete_player_success() {
        let repository = Arc::new(InMemoryPlayerRepository::new());
        let service = DeletePlayerApplicationService::new(repository.clone());

        // テストデータを作成
        let player_name = PlayerName::new("迅悠一".to_string()).unwrap();
        let deck_name = DeckName::new("攻撃型デッキ".to_string()).unwrap();
        let player = Player::create(player_name, deck_name);
        let player_id = player.player_id().value().to_string();

        repository.save(&player).await.unwrap();

        // プレイヤーを削除
        let command = DeletePlayerCommand {
            player_id: player_id.clone(),
        };

        let result = service.execute(command).await;
        assert!(result.is_ok());

        // 削除されているか確認
        let deleted_player = repository
            .find_by_id(&PlayerId::from_string(player_id))
            .await
            .unwrap();
        assert!(deleted_player.is_none());
    }

    #[tokio::test]
    async fn test_delete_player_not_found() {
        let repository = Arc::new(InMemoryPlayerRepository::new());
        let service = DeletePlayerApplicationService::new(repository);

        let command = DeletePlayerCommand {
            player_id: "non-existent-id".to_string(),
        };

        let result = service.execute(command).await;
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "プレイヤーが存在しません");
    }
}
```

以上で、CRUD操作を実現するアプリケーションサービスの実装は完了です。

基本的なユースケースはこれらの実装をベースに表現することが可能です。アプリケーションサービスの実装で重要なのは、ドメイン知識をドメインオブジェクト内に閉じ込め、ドメインオブジェクトを利用してユースケースを実現することです。アプリケーションサービス内にドメイン知識が漏れていないかを常に意識して実装するようにしましょう。

## Rustでのアプリケーションサービス実装のポイント

### 1. コマンドパターンの活用

アプリケーションサービスへの入力は、専用のコマンド構造体にまとめます。

```rust
#[derive(Debug, Clone)]
pub struct RegisterPlayerCommand {
    pub player_name: String,
    pub deck_name: String,
}
```

### 2. Result型によるエラーハンドリング

すべてのアプリケーションサービスメソッドは `Result` 型を返し、エラーを適切に伝播させます。

```rust
pub async fn execute(&self, command: RegisterPlayerCommand) -> Result<String, String> {
    // ...
}
```

### 3. DTOによるデータ転送

ドメインオブジェクトをプレゼンテーション層に直接公開せず、DTOを経由してデータを渡します。

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlayerDTO {
    pub player_id: String,
    pub player_name: String,
    // ...
}

impl PlayerDTO {
    pub fn from_player(player: &Player) -> Self {
        // ...
    }
}
```

### 4. リポジトリの依存性注入

リポジトリは `Arc` でラップして共有し、ジェネリクスでトレイト境界を設定します。

```rust
pub struct RegisterPlayerApplicationService<R>
where
    R: PlayerRepository,
{
    player_repository: Arc<R>,
}
```

### 5. トランザクション管理（オプション）

複数のリポジトリ操作が必要な場合は、トランザクション管理を考慮します。DynamoDBの場合：

```rust
pub trait TransactionManager: Send + Sync {
    async fn execute<F, T>(&self, f: F) -> Result<T, String>
    where
        F: FnOnce() -> futures::future::BoxFuture<'static, Result<T, String>> + Send;
}

// トランザクション内で複数の操作を実行
pub async fn execute_with_transaction(&self, command: SomeCommand) -> Result<(), String> {
    self.transaction_manager.execute(|| {
        Box::pin(async move {
            // 複数のリポジトリ操作
            self.player_repository.save(&player).await?;
            self.match_repository.save(&match_data).await?;
            Ok(())
        })
    }).await
}
```

### 6. テストでのモック活用

テストでは、インメモリリポジトリを使用して高速かつ独立したテストを実現します。

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::infrastructure::in_memory::player_in_memory_repository::InMemoryPlayerRepository;

    #[tokio::test]
    async fn test_some_use_case() {
        let repository = Arc::new(InMemoryPlayerRepository::new());
        let service = SomeApplicationService::new(repository);
        // テスト実行
    }
}
```

## まとめ

- **アプリケーションサービスは、ユースケースを実現するための操作を提供するサービス**
- **アプリケーションサービスは、ドメインオブジェクトを利用してユースケースを実現する**
- **DTOを使用することで、ドメインオブジェクトをプレゼンテーション層から隔離できる**
- **ビジネスロジックはドメイン層に集約し、アプリケーションサービスはそれらを組み合わせるだけにする**
- **Rustでは、`Result`型、`Arc`、トレイト境界、`async/await`を活用してテスタブルなアプリケーションサービスを実装できる**

本章では、アプリケーションサービスの説明と実装を行いました。次章では、プレゼンテーション層の実装を行います。APIを利用してアプリケーションサービスを呼び出し、システムを構築していきましょう。
