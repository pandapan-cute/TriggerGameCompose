# エンティティの実装 (Rust版)

## エンティティとは

エンティティ (Entity) とは、値オブジェクトと並びドメインモデル (ドメインオブジェクト) の中心的な要素で、ドメイン内のさまざまなビジネスの実体の概念をモデル化するのに用いられます。たとえばエンティティには、プレイヤー、ユニット、マッチング、ゲームなどが挙げられます。

### 値オブジェクトとの違い

エンティティと値オブジェクトは、どちらもドメインモデルの中心的な要素ですが、別物です。それらを区別する概念は **同一性 (Identity)** にあります。

#### エンティティの同一性

エンティティは「誰であるか」や「何であるか」という概念によって同一性が定義されます。エンティティを説明するのによく「人」が例に挙げられます。人には名前や住所、年齢などの属性がありますが、それらの属性が変わっても、その人は同じ人であり続けます。たとえば、誕生日を迎え、年齢が変わってもその人は同じ人です。エンティティの同一性は、それを構成する属性の値に依存しません。

そして、エンティティは同一であるという概念を、一意に識別する **「ID」** を割り当てることで表現します。この **「ID」** によってエンティティのインスタンスは区別されます。たとえ属性が時間の経過と共に変わっても、その「ID」が同じであれば、それは同一のエンティティと見なされます。

```rust
pub struct Person {
    person_id: String,
    name: String,
    age: u32,
    address: String,
}

impl Person {
    pub fn new(person_id: String, name: String, age: u32, address: String) -> Self {
        Self {
            person_id,
            name,
            age,
            address,
        }
    }

    pub fn celebrate_birthday(&mut self) {
        self.age += 1;
    }

    pub fn person_id(&self) -> &str {
        &self.person_id
    }
}

// 山田太郎さんが誕生
let mut person1 = Person::new(
    "1".to_string(),
    "山田太郎".to_string(),
    0,
    "東京都".to_string()
);

// 東京の山田太郎さんが誕生日を迎え、年齢が1歳になった
person1.celebrate_birthday();

// 一意な識別子「person_id」が同一であるため、同一のエンティティと見なされる
println!("{:?}", person1); // Person { person_id: "1", name: "山田太郎", age: 1, address: "東京都" }
```

#### 値オブジェクトの同一性

一方で、値オブジェクトはその属性によって同一性が定義されるものです。値オブジェクトには識別子がなく、その属性の値がすべてであり、それらの値が同じであれば、それは同じ値オブジェクトと見なされます。値オブジェクトの同一性は、それを構成する属性の値の組み合わせに依存します。

```rust
#[derive(Debug, PartialEq, Eq)]
pub struct BookId(String);

impl BookId {
    pub fn new(value: String) -> Self {
        Self(value)
    }
}

let book_id1 = BookId::new("9784167158057".to_string());
let book_id2 = BookId::new("9784167158057".to_string());

// 同一であることの確認
assert_eq!(book_id1, book_id2); // true
```

### エンティティの特徴

値同様エンティティにもいくつかの特徴があります。

- **一意な識別子によって区別される**
- **可変である**
- **ライフサイクルがある**

#### 一意な識別子によって区別される

さきほど説明した通り、エンティティはその一意な識別子によって区別されます。この識別子はエンティティが生成された瞬間に割り当てられ、そのライフサイクルの終わりまで変わることはありません。この識別子のおかげで、属性が時間と共に変化しても、エンティティの同一性は保たれ続けます。

#### 可変である

エンティティは値オブジェクトとは反対に、その状態が変更可能です。属性や関連するオブジェクトが変更されることがあり、エンティティの状態はその内容を反映できます。

#### ライフサイクルがある

エンティティには明確なライフサイクルが存在します。生成、変更、そして場合によっては削除というプロセスを経ることで、エンティティは時間の経過と共にビジネスプロセスに沿って変化します。

## エンティティの実装

それでは、実際に `Unit`（ユニット）エンティティを例にエンティティを実装していきましょう。

### ドメインモデルの確認

まず、ドメインモデリングで設計した `Unit` エンティティの属性やビジネスルールを確認します。

```
Unit (ユニット) << Entity >>
  - UnitId: ユニットID (識別子)
  - UnitName: ユニット名
  - Level: レベル
  - Status: ステータス (Active, Inactive)

ビジネスルール:
  - 初回作成時、レベルは 1 から始まる
  - ステータスは Active から始まる
  - レベルアップは現在のレベル + 1
  - レベルは 100 を超えることはできない
  - Inactive 状態のユニットは削除可能
```

### 基本的な実装

まず、`rust_app/src/domain/unit_management/models/unit.rs` に基本的なエンティティの構造を実装します。

```rust
use uuid::Uuid;

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum UnitStatus {
    Active,
    Inactive,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct UnitId(String);

impl UnitId {
    pub fn new() -> Self {
        Self(Uuid::new_v4().to_string())
    }

    pub fn from_string(value: String) -> Self {
        Self(value)
    }

    pub fn value(&self) -> &str {
        &self.0
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct UnitName(String);

impl UnitName {
    pub fn new(value: String) -> Result<Self, String> {
        if value.is_empty() {
            return Err("ユニット名は空にできません".to_string());
        }
        if value.len() > 50 {
            return Err("ユニット名は50文字以内である必要があります".to_string());
        }
        Ok(Self(value))
    }

    pub fn value(&self) -> &str {
        &self.0
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Level(u32);

impl Level {
    pub fn new(value: u32) -> Result<Self, String> {
        if value < 1 {
            return Err("レベルは1以上である必要があります".to_string());
        }
        if value > 100 {
            return Err("レベルは100以下である必要があります".to_string());
        }
        Ok(Self(value))
    }

    pub fn value(&self) -> u32 {
        self.0
    }

    pub fn increment(&self) -> Result<Self, String> {
        Level::new(self.0 + 1)
    }
}

pub struct Unit {
    unit_id: UnitId,
    unit_name: UnitName,
    level: Level,
    status: UnitStatus,
}

impl Unit {
    // privateなコンストラクタ
    fn new(unit_id: UnitId, unit_name: UnitName, level: Level, status: UnitStatus) -> Self {
        Self {
            unit_id,
            unit_name,
            level,
            status,
        }
    }

    // 新規エンティティの生成
    pub fn create(unit_name: UnitName) -> Self {
        let default_unit_id = UnitId::new(); // 自動ID採番
        let default_level = Level::new(1).unwrap(); // デフォルトレベルは1
        let default_status = UnitStatus::Active; // デフォルトステータスは Active

        Self::new(default_unit_id, unit_name, default_level, default_status)
    }

    // エンティティの再構築（リポジトリから取得時に使用）
    pub fn reconstruct(
        unit_id: UnitId,
        unit_name: UnitName,
        level: Level,
        status: UnitStatus,
    ) -> Self {
        Self::new(unit_id, unit_name, level, status)
    }

    // ゲッター
    pub fn unit_id(&self) -> &UnitId {
        &self.unit_id
    }

    pub fn unit_name(&self) -> &UnitName {
        &self.unit_name
    }

    pub fn level(&self) -> &Level {
        &self.level
    }

    pub fn status(&self) -> &UnitStatus {
        &self.status
    }
}
```

### エンティティの特徴の実装

それでは、Unit エンティティを用いて、エンティティの特徴がどのように実装されているかを確認しましょう。

#### 一意な識別子によって区別される

`UnitId` は一意な識別子です。この `UnitId` はエンティティの生成時に割り当てられ、そのライフサイクルの終わりまで変わることはありません。Rustでは、フィールドをprivateにし、ゲッターのみを提供することで不変性を保証します。

```rust
let unit = Unit::create(UnitName::new("迅悠一".to_string()).unwrap());

// unit_idは取得できるが、変更はできない
let id = unit.unit_id();
// unit.unit_id = UnitId::new(); // コンパイルエラー：プライベートフィールドへのアクセス不可
```

#### 可変である

自身に定義されているメソッドを用いて、エンティティの状態を変更することができます。

```rust
impl Unit {
    // ステータスを変更
    fn change_status(&mut self, new_status: UnitStatus) {
        self.status = new_status;
    }

    // ユニット名を変更
    pub fn change_name(&mut self, new_name: UnitName) {
        self.unit_name = new_name;
    }

    // レベルアップ
    pub fn level_up(&mut self) -> Result<(), String> {
        match self.level.increment() {
            Ok(new_level) => {
                self.level = new_level;
                Ok(())
            }
            Err(e) => Err(e),
        }
    }
}

// 使用例
let mut unit = Unit::create(UnitName::new("迅悠一".to_string()).unwrap());

// 名前を変更
unit.change_name(UnitName::new("迅".to_string()).unwrap());
println!("{:?}", unit.unit_name()); // "迅"

// レベルアップ
unit.level_up().unwrap();
println!("{:?}", unit.level().value()); // 2
```

#### ライフサイクルがある

`create`、変更メソッド、`delete` メソッドを用いて、エンティティのライフサイクルを表現することができます。

```rust
impl Unit {
    pub fn delete(&self) -> Result<(), String> {
        if self.status != UnitStatus::Inactive {
            return Err("Active状態のユニットは削除できません".to_string());
        }
        Ok(())
    }

    pub fn deactivate(&mut self) {
        self.change_status(UnitStatus::Inactive);
    }

    pub fn activate(&mut self) {
        self.change_status(UnitStatus::Active);
    }
}

// 使用例
let mut unit = Unit::create(UnitName::new("迅悠一".to_string()).unwrap());

// レベルアップ
unit.level_up().unwrap();

// 非アクティブ化
unit.deactivate();

// 削除
unit.delete().unwrap(); // 成功
```

### ビジネスルールの適用

実装したエンティティにビジネスルールを適用する必要があります。エンティティのライフサイクルにビジネスルールを適用していきましょう。

```rust
use uuid::Uuid;

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum UnitStatus {
    Active,
    Inactive,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct UnitId(String);

impl UnitId {
    pub fn new() -> Self {
        Self(Uuid::new_v4().to_string())
    }

    pub fn from_string(value: String) -> Self {
        Self(value)
    }

    pub fn value(&self) -> &str {
        &self.0
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct UnitName(String);

impl UnitName {
    pub fn new(value: String) -> Result<Self, String> {
        if value.is_empty() {
            return Err("ユニット名は空にできません".to_string());
        }
        if value.len() > 50 {
            return Err("ユニット名は50文字以内である必要があります".to_string());
        }
        Ok(Self(value))
    }

    pub fn value(&self) -> &str {
        &self.0
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Level(u32);

impl Level {
    pub fn new(value: u32) -> Result<Self, String> {
        if value < 1 {
            return Err("レベルは1以上である必要があります".to_string());
        }
        if value > 100 {
            return Err("レベルは100以下である必要があります".to_string());
        }
        Ok(Self(value))
    }

    pub fn value(&self) -> u32 {
        self.0
    }

    pub fn increment(&self) -> Result<Self, String> {
        Level::new(self.0 + 1)
    }
}

pub struct Unit {
    unit_id: UnitId,
    unit_name: UnitName,
    level: Level,
    status: UnitStatus,
}

impl Unit {
    // privateなコンストラクタ
    fn new(unit_id: UnitId, unit_name: UnitName, level: Level, status: UnitStatus) -> Self {
        Self {
            unit_id,
            unit_name,
            level,
            status,
        }
    }

    // 新規エンティティの生成（ビジネスルール適用）
    pub fn create(unit_name: UnitName) -> Self {
        let default_unit_id = UnitId::new(); // 自動ID採番
        let default_level = Level::new(1).unwrap(); // デフォルトレベルは1
        let default_status = UnitStatus::Active; // デフォルトステータスは Active

        Self::new(default_unit_id, unit_name, default_level, default_status)
    }

    // エンティティの再構築（リポジトリから取得時に使用）
    pub fn reconstruct(
        unit_id: UnitId,
        unit_name: UnitName,
        level: Level,
        status: UnitStatus,
    ) -> Self {
        Self::new(unit_id, unit_name, level, status)
    }

    // 削除（ビジネスルール: Inactive状態のみ削除可能）
    pub fn delete(&self) -> Result<(), String> {
        if self.status != UnitStatus::Inactive {
            return Err("Active状態のユニットは削除できません".to_string());
        }
        Ok(())
    }

    // ステータスを変更（private）
    fn change_status(&mut self, new_status: UnitStatus) {
        self.status = new_status;
    }

    // ユニット名を変更
    pub fn change_name(&mut self, new_name: UnitName) {
        self.unit_name = new_name;
    }

    // レベルアップ（ビジネスルール: レベル100を超えられない）
    pub fn level_up(&mut self) -> Result<(), String> {
        match self.level.increment() {
            Ok(new_level) => {
                self.level = new_level;
                Ok(())
            }
            Err(e) => Err(e),
        }
    }

    // 非アクティブ化
    pub fn deactivate(&mut self) {
        self.change_status(UnitStatus::Inactive);
    }

    // アクティブ化
    pub fn activate(&mut self) {
        self.change_status(UnitStatus::Active);
    }

    // ゲッター
    pub fn unit_id(&self) -> &UnitId {
        &self.unit_id
    }

    pub fn unit_name(&self) -> &UnitName {
        &self.unit_name
    }

    pub fn level(&self) -> &Level {
        &self.level
    }

    pub fn status(&self) -> &UnitStatus {
        &self.status
    }
}
```

#### ビジネスルールの詳細説明

**1. `create` メソッドでのビジネスルール適用**

`create` メソッドでは、デフォルトの値を設定しています。このデフォルトの値は、たとえば「初期レベルは `1`、初期ステータスは `Active`」というように、ビジネスルールによって決まった値です。このようにすることで生成時は必ずビジネスルールに従ったエンティティが生成されるようになります。

```rust
pub fn create(unit_name: UnitName) -> Self {
    let default_unit_id = UnitId::new(); // 自動ID採番
    let default_level = Level::new(1).unwrap(); // デフォルトレベルは1
    let default_status = UnitStatus::Active; // デフォルトステータスは Active

    Self::new(default_unit_id, unit_name, default_level, default_status)
}
```

**2. `delete` メソッドでのビジネスルール適用**

`delete` メソッドでは、「ステータスが Inactive である場合のみユニットを削除できる」というビジネスルールを適用しています。このように、エンティティの状態を変更するメソッドの中で、ビジネスルールを適用することで、エンティティのライフサイクルにビジネスルールを適用することができます。

```rust
pub fn delete(&self) -> Result<(), String> {
    if self.status != UnitStatus::Inactive {
        return Err("Active状態のユニットは削除できません".to_string());
    }
    Ok(())
}
```

**3. `level_up` メソッドでのビジネスルール適用**

エンティティのメソッドはドメインの振る舞いを反映したものであるべきです。`level_up`メソッドは、より直感的にレベルを上げる操作ができるようになりました。さらに「レベルは 100 を超えることができない」というビジネスルールを適用しています。

```rust
pub fn level_up(&mut self) -> Result<(), String> {
    match self.level.increment() {
        Ok(new_level) => {
            self.level = new_level;
            Ok(())
        }
        Err(e) => Err(e),
    }
}
```

> **重要:** エンティティが持つ属性は `private` にして、メソッドを通して変更するようにしましょう。属性を変更するメソッドにビジネスルールを適用することで、ビジネスルールの整合性が崩れるのを防ぐことができます。

### コンストラクタをprivateにする理由

`new` コンストラクタを private にしている理由は、`create` メソッドと `reconstruct` メソッドのみでエンティティを生成することを強制するためです。

- **`create` メソッド**: エンティティの生成時の制御（ビジネスルールの適用）を行います
- **`reconstruct` メソッド**: データベースなどから読み込んだデータをもとにエンティティを再構築する際に使用します

## エンティティのテスト

値オブジェクト同様、ビジネスルールが正しく実装されているかを保証するためにはテストは必須です。`rust_app/src/domain/unit_management/models/unit.rs` と同じディレクトリに、テストモジュールを実装します。

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_unit_with_default_values() {
        let unit_name = UnitName::new("迅悠一".to_string()).unwrap();
        let unit = Unit::create(unit_name.clone());

        assert_eq!(unit.unit_name().value(), "迅悠一");
        assert_eq!(unit.level().value(), 1);
        assert_eq!(unit.status(), &UnitStatus::Active);
    }

    #[test]
    fn test_level_up() {
        let unit_name = UnitName::new("迅悠一".to_string()).unwrap();
        let mut unit = Unit::create(unit_name);

        unit.level_up().unwrap();
        assert_eq!(unit.level().value(), 2);

        unit.level_up().unwrap();
        assert_eq!(unit.level().value(), 3);
    }

    #[test]
    fn test_level_up_max_level() {
        let unit_name = UnitName::new("迅悠一".to_string()).unwrap();
        let level = Level::new(100).unwrap();
        let mut unit = Unit::reconstruct(
            UnitId::new(),
            unit_name,
            level,
            UnitStatus::Active,
        );

        let result = unit.level_up();
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err(),
            "レベルは100以下である必要があります"
        );
    }

    #[test]
    fn test_change_name() {
        let unit_name = UnitName::new("迅悠一".to_string()).unwrap();
        let mut unit = Unit::create(unit_name);

        let new_name = UnitName::new("迅".to_string()).unwrap();
        unit.change_name(new_name);

        assert_eq!(unit.unit_name().value(), "迅");
    }

    #[test]
    fn test_deactivate() {
        let unit_name = UnitName::new("迅悠一".to_string()).unwrap();
        let mut unit = Unit::create(unit_name);

        assert_eq!(unit.status(), &UnitStatus::Active);

        unit.deactivate();
        assert_eq!(unit.status(), &UnitStatus::Inactive);
    }

    #[test]
    fn test_activate() {
        let unit_name = UnitName::new("迅悠一".to_string()).unwrap();
        let mut unit = Unit::create(unit_name);

        unit.deactivate();
        assert_eq!(unit.status(), &UnitStatus::Inactive);

        unit.activate();
        assert_eq!(unit.status(), &UnitStatus::Active);
    }

    #[test]
    fn test_delete_active_unit_should_fail() {
        let unit_name = UnitName::new("迅悠一".to_string()).unwrap();
        let unit = Unit::create(unit_name);

        let result = unit.delete();
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err(),
            "Active状態のユニットは削除できません"
        );
    }

    #[test]
    fn test_delete_inactive_unit_should_succeed() {
        let unit_name = UnitName::new("迅悠一".to_string()).unwrap();
        let mut unit = Unit::create(unit_name);

        unit.deactivate();
        let result = unit.delete();
        assert!(result.is_ok());
    }

    #[test]
    fn test_reconstruct() {
        let unit_id = UnitId::from_string("test-id".to_string());
        let unit_name = UnitName::new("迅悠一".to_string()).unwrap();
        let level = Level::new(50).unwrap();
        let status = UnitStatus::Inactive;

        let unit = Unit::reconstruct(unit_id.clone(), unit_name, level, status);

        assert_eq!(unit.unit_id().value(), "test-id");
        assert_eq!(unit.unit_name().value(), "迅悠一");
        assert_eq!(unit.level().value(), 50);
        assert_eq!(unit.status(), &UnitStatus::Inactive);
    }
}
```

ビジネスロジック、振る舞い（メソッド）、例外処理などを網羅するようにテストを書きます。なるべくテストのカバレッジが 100%に近づけるようにしましょう。

### テストの実行

```bash
cd game_server/rust_app
cargo test unit::tests
```

## Rustでのエンティティ実装のポイント

### 1. 所有権と借用

Rustではエンティティのフィールドへのアクセス時に所有権と借用のルールに従う必要があります。

```rust
// 値を取得（借用）
pub fn unit_name(&self) -> &UnitName {
    &self.unit_name
}

// 値を消費して変更
pub fn change_name(&mut self, new_name: UnitName) {
    self.unit_name = new_name;
}
```

### 2. Result型によるエラーハンドリング

ビジネスルール違反時は `Result` 型を使用してエラーを返します。

```rust
pub fn level_up(&mut self) -> Result<(), String> {
    match self.level.increment() {
        Ok(new_level) => {
            self.level = new_level;
            Ok(())
        }
        Err(e) => Err(e),
    }
}
```

### 3. 不変性の保証

識別子など変更してはいけないフィールドは、ゲッターのみ提供し、セッターは実装しません。Rustのプライベートフィールドとして宣言することで、外部からの変更を防ぎます。

```rust
pub struct Unit {
    unit_id: UnitId,  // privateフィールド
    // ...
}

impl Unit {
    // 借用のみ許可（変更不可）
    pub fn unit_id(&self) -> &UnitId {
        &self.unit_id
    }
}
```

### 4. 型システムによるビジネスルールの強制

値オブジェクトの `new` メソッドで制約をチェックすることで、不正な値を持つエンティティの生成を防ぎます。

```rust
impl UnitName {
    pub fn new(value: String) -> Result<Self, String> {
        if value.is_empty() {
            return Err("ユニット名は空にできません".to_string());
        }
        if value.len() > 50 {
            return Err("ユニット名は50文字以内である必要があります".to_string());
        }
        Ok(Self(value))
    }
}
```

## まとめ

- **エンティティを利用することで、ライフサイクルの整合性を担保できる**
- **エンティティ自身がドキュメントになる**
- **Rustの型システムと所有権モデルを活用して、より安全なエンティティを実装できる**
- **`Result` 型を使用してビジネスルール違反を明示的に表現できる**

本章では、値オブジェクトとエンティティの違い、エンティティの実装方法について学びました。エンティティにビジネスルールをカプセル化することで、ドメインの整合性を保ちながら、変更可能な状態を安全に管理できるようになります。

次のステップでは、ドメイン駆動設計の中でも非常に重要で難しい概念である集約について学び、実装していきます。
