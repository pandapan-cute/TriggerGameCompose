# リポジトリの実装 (Rust版)

## リポジトリとは

リポジトリ (Repository) とは、インフラストラクチャ層のオブジェクトで、集約の永続化を抽象化する役割を果たします。リポジトリの主な目的は、ドメインモデルやビジネスロジックをデータ永続化の詳細（どのデータベース、ORMを利用するか）から切り離すことです。これにより、ドメインモデルがデータベースのスキーマやデータアクセスなどの特定の技術に依存することなく、ドメイン知識の表現に集中できるようになります。

リポジトリの責務は大きく二つに分かれます。一つは集約の永続化で、これにはエンティティの新規作成や既存のエンティティの更新が含まれます。もう一つは集約の復元で、これはデータベースからエンティティを取得し、ドメインオブジェクトとしてアプリケーションサービスに渡すプロセスを指します。リポジトリはこれらのプロセスを通して、ドメインモデルとデータベースの間の橋渡しを行います。

> **Note:** この章ではデータベースにAmazon DynamoDB、AWS SDK for Rustを使用します。ここで重要なのは、具体的な実装の内容ではなく、リポジトリの役割を理解することです。リポジトリはデータベースの永続化を抽象化することが目的です。そのため、データの永続化には、システムの要件に合わせて RDB や NoSQL など、何を選択しても構いません。DynamoDBはサーバーレスのNoSQLデータベースで、高速かつスケーラブルな特性を持ちます。

## リポジトリを適用しないケース

まず、リポジトリを適用しないケースから確認していきましょう。前章で作成した `PlayerNameDuplicationCheckDomainService` で、プレイヤー名の重複チェックをデータベースから取得したデータを利用する形に変更します。

```rust
// リポジトリを適用せずに実装
use aws_sdk_dynamodb::Client as DynamoDbClient;
use aws_sdk_dynamodb::types::AttributeValue;

pub struct PlayerNameDuplicationCheckDomainService {
    dynamodb_client: DynamoDbClient,
    table_name: String,
}

impl PlayerNameDuplicationCheckDomainService {
    pub fn new(dynamodb_client: DynamoDbClient, table_name: String) -> Self {
        Self { 
            dynamodb_client,
            table_name,
        }
    }

    pub async fn execute(&self, player_name: &PlayerName) -> Result<bool, String> {
        // DynamoDBに問い合わせて重複があるか確認する
        // GSI（Global Secondary Index）を使用してプレイヤー名で検索
        let result = self.dynamodb_client
            .query()
            .table_name(&self.table_name)
            .index_name("PlayerNameIndex")
            .key_condition_expression("player_name = :name")
            .expression_attribute_values(
                ":name",
                AttributeValue::S(player_name.value().to_string())
            )
            .send()
            .await
            .map_err(|e| format!("DynamoDB error: {}", e))?;

        Ok(result.items().map(|items| !items.is_empty()).unwrap_or(false))
    }
}
```

上記のコードでは、直接ドメインサービス内で AWS SDK for Rust を利用しDynamoDBへのアクセスを記述しています。これでは、ドメイン層がデータベースアクセスの詳細を知ることになり、ドメイン知識の表現に集中できなくなります。そして、これはオニオンアーキテクチャの考え方に反しています。データベースへのアクセスはインフラストラクチャ層の責務です。ドメイン層がインフラストラクチャ層に依存することは許されていません。

オニオンアーキテクチャに違反することでどのような問題が発生するのでしょうか？具体的には以下のような問題が発生します。

- **テストの複雑化**
- **変更容易性の低下**

### テストの複雑化

実際にこの状態でテストを書いてみることで、テストの複雑性を確認していきます。

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_player_name_not_duplicate() {
        // DynamoDB接続のセットアップが必要
        let config = aws_config::load_from_env().await;
        let client = DynamoDbClient::new(&config);
        let table_name = "Players".to_string();
        
        // テストデータの準備（テーブル内のデータをクリーンアップ）
        // DynamoDBではテーブル全体のクリアが容易ではない
        
        let service = PlayerNameDuplicationCheckDomainService::new(client, table_name);
        let player_name = PlayerName::new("迅悠一".to_string()).unwrap();
        
        let result = service.execute(&player_name).await.unwrap();
        assert!(!result);
    }
}
```

このテストでは、実際のDynamoDB接続が必要になるため、テストのセットアップが複雑になります。テストを実行するには：

- AWS認証情報が設定されている必要がある
- DynamoDBのテーブルが作成されている必要がある
- テスト用のテーブル/環境を用意する必要がある
- テスト間でデータの競合が発生する可能性がある
- テストの実行速度が遅くなる（ネットワーク通信を伴う）

また、テストが特定のAWS SDKの振る舞いに依存しているため、SDKの変更やバージョンアップによりテストが影響を受ける可能性があります。

### 変更容易性の低下

ドメイン層が特定のデータベース技術に依存すると、将来的な技術変更が困難になります。たとえば、DynamoDBから別のNoSQLデータベース（MongoDB、Cassandraなど）やRDBに変更したい場合、ドメイン層のコードも大きく変更する必要が出てきます。

また、ドメイン層がデータベースアクセスロジックを含むことで、ビジネスロジックとインフラストラクチャの関心が混在します。これにより、ビジネスロジックの見通しが悪くなり、保守性が低下します。

## リポジトリを適用するケース

リポジトリを適用しない場合の問題点を確認したので、リポジトリを適用した実装に修正し、どのように、これらの問題点を解決するか確認していきます。

### リポジトリのトレイト（インターフェイス）

ドメインサービスはドメイン層のオブジェクトです。インフラストラクチャのオブジェクトであるリポジトリを直接利用する（依存する）ことは、オニオンアーキテクチャに反しています。そこで**依存性逆転の原則 (DIP)** に従い、リポジトリの抽象、つまりトレイトを定義し、トレイトに具体的な実装を依存させるように DI する必要があります。

それでは、リポジトリのトレイトを作成しましょう。

```rust
// domain/player_management/repositories/player_repository.rs

use crate::domain::player_management::models::player::{Player, PlayerId, PlayerName};
use async_trait::async_trait;

/// Playerリポジトリのトレイト
#[async_trait]
pub trait PlayerRepository: Send + Sync {
    /// プレイヤーを保存
    async fn save(&self, player: &Player) -> Result<(), String>;
    
    /// プレイヤーを更新
    async fn update(&self, player: &Player) -> Result<(), String>;
    
    /// プレイヤーを削除
    async fn delete(&self, player_id: &PlayerId) -> Result<(), String>;
    
    /// IDでプレイヤーを検索
    async fn find_by_id(&self, player_id: &PlayerId) -> Result<Option<Player>, String>;
    
    /// プレイヤー名でプレイヤーを検索
    async fn find_by_name(&self, player_name: &PlayerName) -> Result<Option<Player>, String>;
}
```

`PlayerNameDuplicationCheckDomainService` では `find_by_name` メソッドを利用します。`find_by_name` は `PlayerName` を受け取り、Player 集約を返すメソッドです。Player 集約が存在しない場合は `None` を返します。ここではその他にも、`save`、`update`、`delete`、`find_by_id` といったメソッドを定義しています。

> **Note:** リポジトリの設計では、実際に使用されるか、将来的に使用されることが予定されているメソッドのみを定義すると良いでしょう。不必要なメソッドを「いつか使うかもしれない」という理由で定義すると、トレイトが複雑化し、保守性や理解のしやすさが低下する恐れがあります。

### リポジトリのトレイトを利用してみる

それでは、`PlayerNameDuplicationCheckDomainService` が `PlayerRepository` トレイトのリポジトリを依存性注入を通じて受け取るように変更します。

```rust
// domain/player_management/services/player_name_duplication_check_domain_service.rs

use crate::domain::player_management::models::player::player_name::player_name::PlayerName;
use crate::domain::player_management::repositories::player_repository::PlayerRepository;
use std::sync::Arc;

pub struct PlayerNameDuplicationCheckDomainService<R>
where
    R: PlayerRepository,
{
    player_repository: Arc<R>,
}

impl<R> PlayerNameDuplicationCheckDomainService<R>
where
    R: PlayerRepository,
{
    pub fn new(player_repository: Arc<R>) -> Self {
        Self { player_repository }
    }

    pub async fn execute(&self, player_name: &PlayerName) -> Result<bool, String> {
        // リポジトリを通じてデータベースに問い合わせる
        let duplicate_player = self.player_repository
            .find_by_name(player_name)
            .await?;
        
        Ok(duplicate_player.is_some())
    }
}
```

リポジトリを利用することで、ドメインサービスはデータベースアクセスの詳細を知る必要がなくなり、ドメイン知識の表現に集中できるようになりました。また、抽象型である `PlayerRepository` トレイトにリポジトリの実装を依存させるようにすることで、具体的なデータベースアクセスを行うオブジェクトが未実装でもドメインサービスを実装することができています。つまり、ドメイン層がインフラストラクチャ層に依存しない状態を保つことができました。

### ドメインサービスのテスト

次に、リポジトリを利用したケースのテストを書いていきましょう。`PlayerNameDuplicationCheckDomainService` はリポジトリを `PlayerRepository` トレイトに依存しています。そのため、テストではテスト用の軽量なリポジトリを DI してテストすることが可能です。

ここでは、テストのためにインメモリを利用した軽量なリポジトリを実装し、テストを行います。

```rust
// infrastructure/in_memory/player_in_memory_repository.rs

use crate::domain::player_management::models::player::{Player, PlayerId, PlayerName};
use crate::domain::player_management::repositories::player_repository::PlayerRepository;
use async_trait::async_trait;
use std::collections::HashMap;
use std::sync::RwLock;

pub struct InMemoryPlayerRepository {
    db: RwLock<HashMap<String, Player>>,
}

impl InMemoryPlayerRepository {
    pub fn new() -> Self {
        Self {
            db: RwLock::new(HashMap::new()),
        }
    }
}

#[async_trait]
impl PlayerRepository for InMemoryPlayerRepository {
    async fn save(&self, player: &Player) -> Result<(), String> {
        let mut db = self.db.write().unwrap();
        db.insert(player.player_id().value().to_string(), player.clone());
        Ok(())
    }

    async fn update(&self, player: &Player) -> Result<(), String> {
        let mut db = self.db.write().unwrap();
        db.insert(player.player_id().value().to_string(), player.clone());
        Ok(())
    }

    async fn delete(&self, player_id: &PlayerId) -> Result<(), String> {
        let mut db = self.db.write().unwrap();
        db.remove(player_id.value());
        Ok(())
    }

    async fn find_by_id(&self, player_id: &PlayerId) -> Result<Option<Player>, String> {
        let db = self.db.read().unwrap();
        Ok(db.get(player_id.value()).cloned())
    }

    async fn find_by_name(&self, player_name: &PlayerName) -> Result<Option<Player>, String> {
        let db = self.db.read().unwrap();
        Ok(db.values()
            .find(|p| p.player_name().value() == player_name.value())
            .cloned())
    }
}
```

このリポジトリはインメモリ上に集約の保存、取得を行うことができます。非常にシンプルで軽量なリポジトリです。

それでは、作成した `InMemoryPlayerRepository` を利用したテストを書いていきましょう。

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::player_management::models::player::{Player, PlayerName, DeckName};
    use crate::infrastructure::in_memory::player_in_memory_repository::InMemoryPlayerRepository;
    use std::sync::Arc;

    #[tokio::test]
    async fn test_player_name_not_duplicate() {
        let repository = Arc::new(InMemoryPlayerRepository::new());
        let service = PlayerNameDuplicationCheckDomainService::new(repository);
        
        let player_name = PlayerName::new("迅悠一".to_string()).unwrap();
        let result = service.execute(&player_name).await.unwrap();
        
        assert!(!result);
    }

    #[tokio::test]
    async fn test_player_name_duplicate() {
        let repository = Arc::new(InMemoryPlayerRepository::new());
        
        // テストデータを保存
        let player_name = PlayerName::new("迅悠一".to_string()).unwrap();
        let deck_name = DeckName::new("テストデッキ".to_string()).unwrap();
        let player = Player::create(player_name.clone(), deck_name);
        repository.save(&player).await.unwrap();
        
        let service = PlayerNameDuplicationCheckDomainService::new(repository);
        let result = service.execute(&player_name).await.unwrap();
        
        assert!(result);
    }

    #[tokio::test]
    async fn test_different_player_name_not_duplicate() {
        let repository = Arc::new(InMemoryPlayerRepository::new());
        
        // 異なるプレイヤーを保存
        let existing_name = PlayerName::new("迅悠一".to_string()).unwrap();
        let deck_name = DeckName::new("テストデッキ".to_string()).unwrap();
        let player = Player::create(existing_name, deck_name);
        repository.save(&player).await.unwrap();
        
        // 別の名前でチェック
        let new_name = PlayerName::new("三雲修".to_string()).unwrap();
        let service = PlayerNameDuplicationCheckDomainService::new(repository);
        let result = service.execute(&new_name).await.unwrap();
        
        assert!(!result);
    }
}
```

`InMemoryPlayerRepository` を利用してテストを書くことで、テストのためにデータベースの実行環境を用意する必要がなくなります。また、テストのセットアップが簡単になり、実行速度もデータベースを利用する場合よりも向上します。

## DynamoDBを利用したリポジトリの実装

それでは実際の環境で利用する、AWS SDK for Rust を利用したリポジトリを実装していきましょう。

### DynamoDBのテーブル設計

まず、DynamoDBのテーブル設計について確認します。

**Playersテーブル:**
- パーティションキー: `player_id` (String)
- 属性: `player_name` (String), `level` (Number)
- GSI: `PlayerNameIndex` - パーティションキー: `player_name`

**Decksテーブル:**
- パーティションキー: `deck_id` (String)
- 属性: `player_id` (String), `deck_name` (String), `max_size` (Number), `unit_ids` (StringSet)

または、単一テーブル設計も可能です：

**GameDataテーブル（単一テーブル設計）:**
- パーティションキー: `PK` (String) - 例: `PLAYER#<player_id>`
- ソートキー: `SK` (String) - 例: `PROFILE` または `DECK#<deck_id>`
- GSI: `GSI1` - パーティションキー: `GSI1PK` (例: `PLAYERNAME#<player_name>`), ソートキー: `GSI1SK`

ここでは、シンプルさのため複数テーブル設計で実装例を示します。

### リポジトリの実装

```rust
// infrastructure/dynamodb/player_dynamodb_repository.rs

use crate::domain::player_management::models::player::{
    Player, PlayerId, PlayerName, DeckName, Level, Deck, DeckId
};
use crate::domain::player_management::repositories::player_repository::PlayerRepository;
use async_trait::async_trait;
use aws_sdk_dynamodb::Client as DynamoDbClient;
use aws_sdk_dynamodb::types::AttributeValue;
use std::collections::HashMap;

pub struct DynamoDbPlayerRepository {
    client: DynamoDbClient,
    players_table: String,
    decks_table: String,
}

impl DynamoDbPlayerRepository {
    pub fn new(client: DynamoDbClient, players_table: String, decks_table: String) -> Self {
        Self {
            client,
            players_table,
            decks_table,
        }
    }

    // ヘルパーメソッド：Playerを属性値マップに変換
    fn player_to_item(&self, player: &Player) -> HashMap<String, AttributeValue> {
        let mut item = HashMap::new();
        item.insert(
            "player_id".to_string(),
            AttributeValue::S(player.player_id().value().to_string()),
        );
        item.insert(
            "player_name".to_string(),
            AttributeValue::S(player.player_name().value().to_string()),
        );
        item.insert(
            "level".to_string(),
            AttributeValue::N(player.level().value().to_string()),
        );
        item
    }

    // ヘルパーメソッド：Deckを属性値マップに変換
    fn deck_to_item(&self, player: &Player) -> HashMap<String, AttributeValue> {
        let mut item = HashMap::new();
        item.insert(
            "deck_id".to_string(),
            AttributeValue::S(player.deck_id().value().to_string()),
        );
        item.insert(
            "player_id".to_string(),
            AttributeValue::S(player.player_id().value().to_string()),
        );
        item.insert(
            "deck_name".to_string(),
            AttributeValue::S(player.deck_name().value().to_string()),
        );
        item.insert(
            "max_size".to_string(),
            AttributeValue::N(player.deck_unit_count().to_string()),
        );
        
        // ユニットIDをStringSetとして保存
        let unit_ids: Vec<String> = player.deck_unit_ids()
            .iter()
            .map(|id| id.to_string())
            .collect();
        if !unit_ids.is_empty() {
            item.insert(
                "unit_ids".to_string(),
                AttributeValue::Ss(unit_ids),
            );
        }
        item
    }
}

#[async_trait]
impl PlayerRepository for DynamoDbPlayerRepository {
    async fn save(&self, player: &Player) -> Result<(), String> {
        // Playerアイテムを保存
        let player_item = self.player_to_item(player);
        self.client
            .put_item()
            .table_name(&self.players_table)
            .set_item(Some(player_item))
            .send()
            .await
            .map_err(|e| format!("Failed to save player: {}", e))?;

        // Deckアイテムを保存
        let deck_item = self.deck_to_item(player);
        self.client
            .put_item()
            .table_name(&self.decks_table)
            .set_item(Some(deck_item))
            .send()
            .await
            .map_err(|e| format!("Failed to save deck: {}", e))?;

        Ok(())
    }

    async fn update(&self, player: &Player) -> Result<(), String> {
        // DynamoDBでは put_item で上書き更新
        // または update_item を使用して部分更新
        self.client
            .update_item()
            .table_name(&self.players_table)
            .key("player_id", AttributeValue::S(player.player_id().value().to_string()))
            .update_expression("SET player_name = :name, #level = :level")
            .expression_attribute_names("#level", "level")
            .expression_attribute_values(
                ":name",
                AttributeValue::S(player.player_name().value().to_string())
            )
            .expression_attribute_values(
                ":level",
                AttributeValue::N(player.level().value().to_string())
            )
            .send()
            .await
            .map_err(|e| format!("Failed to update player: {}", e))?;

        // Deckも更新
        self.client
            .update_item()
            .table_name(&self.decks_table)
            .key("deck_id", AttributeValue::S(player.deck_id().value().to_string()))
            .update_expression("SET deck_name = :deck_name")
            .expression_attribute_values(
                ":deck_name",
                AttributeValue::S(player.deck_name().value().to_string())
            )
            .send()
            .await
            .map_err(|e| format!("Failed to update deck: {}", e))?;

        Ok(())
    }

    async fn delete(&self, player_id: &PlayerId) -> Result<(), String> {
        // まずPlayerに紐づくDeckを取得して削除
        if let Some(player) = self.find_by_id(player_id).await? {
            self.client
                .delete_item()
                .table_name(&self.decks_table)
                .key("deck_id", AttributeValue::S(player.deck_id().value().to_string()))
                .send()
                .await
                .map_err(|e| format!("Failed to delete deck: {}", e))?;
        }

        // Playerを削除
        self.client
            .delete_item()
            .table_name(&self.players_table)
            .key("player_id", AttributeValue::S(player_id.value().to_string()))
            .send()
            .await
            .map_err(|e| format!("Failed to delete player: {}", e))?;

        Ok(())
    }

    async fn find_by_id(&self, player_id: &PlayerId) -> Result<Option<Player>, String> {
        // Playerアイテムを取得
        let player_result = self.client
            .get_item()
            .table_name(&self.players_table)
            .key("player_id", AttributeValue::S(player_id.value().to_string()))
            .send()
            .await
            .map_err(|e| format!("Failed to get player: {}", e))?;

        let player_item = match player_result.item() {
            Some(item) => item,
            None => return Ok(None),
        };

        // Playerの属性を抽出
        let player_name_str = player_item
            .get("player_name")
            .and_then(|v| v.as_s().ok())
            .ok_or("player_name not found")?;
        let level_num = player_item
            .get("level")
            .and_then(|v| v.as_n().ok())
            .and_then(|s| s.parse::<u32>().ok())
            .ok_or("level not found")?;

        let player_name = PlayerName::new(player_name_str.clone())?;
        let level = Level::new(level_num)?;

        // Deckを取得（Queryを使用してplayer_idでフィルタ）
        let deck_result = self.client
            .query()
            .table_name(&self.decks_table)
            .index_name("PlayerIdIndex") // GSIが必要
            .key_condition_expression("player_id = :pid")
            .expression_attribute_values(
                ":pid",
                AttributeValue::S(player_id.value().to_string())
            )
            .send()
            .await
            .map_err(|e| format!("Failed to query deck: {}", e))?;

        let deck_items = deck_result.items();
        if deck_items.is_empty() {
            return Err("Player found but deck is missing".to_string());
        }

        let deck_item = &deck_items[0];
        let deck_id_str = deck_item
            .get("deck_id")
            .and_then(|v| v.as_s().ok())
            .ok_or("deck_id not found")?;
        let deck_name_str = deck_item
            .get("deck_name")
            .and_then(|v| v.as_s().ok())
            .ok_or("deck_name not found")?;
        let max_size = deck_item
            .get("max_size")
            .and_then(|v| v.as_n().ok())
            .and_then(|s| s.parse::<usize>().ok())
            .ok_or("max_size not found")?;

        let unit_ids: Vec<String> = deck_item
            .get("unit_ids")
            .and_then(|v| v.as_ss().ok())
            .cloned()
            .unwrap_or_default();

        let deck_name = DeckName::new(deck_name_str.clone())?;
        let deck = Deck::reconstruct(
            DeckId::from_string(deck_id_str.clone()),
            deck_name,
            unit_ids,
            max_size,
        );

        Ok(Some(Player::reconstruct(
            PlayerId::from_string(player_id.value().to_string()),
            player_name,
            level,
            deck,
        )))
    }

    async fn find_by_name(&self, player_name: &PlayerName) -> Result<Option<Player>, String> {
        // GSI (PlayerNameIndex) を使用してクエリ
        let result = self.client
            .query()
            .table_name(&self.players_table)
            .index_name("PlayerNameIndex")
            .key_condition_expression("player_name = :name")
            .expression_attribute_values(
                ":name",
                AttributeValue::S(player_name.value().to_string())
            )
            .send()
            .await
            .map_err(|e| format!("Failed to query by name: {}", e))?;

        let items = result.items();
        if items.is_empty() {
            return Ok(None);
        }

        let item = &items[0];
        let player_id_str = item
            .get("player_id")
            .and_then(|v| v.as_s().ok())
            .ok_or("player_id not found")?;

        let player_id = PlayerId::from_string(player_id_str.clone());
        self.find_by_id(&player_id).await
    }
}
```

`PlayerRepository` トレイトを元に、`save`、`update`、`delete`、`find_by_id`、`find_by_name` メソッドをAWS SDK for Rustを利用して実装しています。

### DynamoDBの特徴

- **put_item**: アイテムを新規作成または完全上書き
- **update_item**: アイテムの特定属性を更新
- **get_item**: プライマリキーでアイテムを取得
- **query**: キー条件式を使用してアイテムを検索（GSI使用可能）
- **delete_item**: アイテムを削除

ここで重要なのは AWS SDK の具体的な実装方法ではなく、トレイト `PlayerRepository` の要件を満たす実装ができたということです。これにより、データベースアクセスの詳細をドメイン層から隠蔽し、インフラストラクチャ層に閉じ込めることができます。

## リポジトリのテスト

リポジトリのテストには以下の 2 種類あります。

- **リポジトリを利用する側のコードが集約の入出力を正しく行えるか**
- **リポジトリ自体が正しく動くか**

### リポジトリを利用する側のコードが集約の入出力を正しく行えるか

一つが `PlayerNameDuplicationCheckDomainService` のような、リポジトリを利用する側のコードが集約の入出力を正しく行えるか確認するテストです。これは、前述のようにテスト用のリポジトリ（インメモリを利用したリポジトリ）を利用してテストを行うことで確認することができました。

### リポジトリ自体が正しく動くか

もう一つが、リポジトリ自体が正しく動くか確認するテストです。このテストでは実際にDynamoDBにアクセスし、データの永続化や復元が正しく行えるか確認します。

```rust
#[cfg(test)]
mod tests {
    use super::*;

    async fn setup_test_client() -> (DynamoDbClient, String, String) {
        // ローカルのDynamoDB Localや実際のAWS環境を使用
        let config = aws_config::load_from_env().await;
        let client = DynamoDbClient::new(&config);
        
        let players_table = "Players-test".to_string();
        let decks_table = "Decks-test".to_string();
        
        // テストデータをクリア（必要に応じて）
        // DynamoDBでは全スキャン→削除が必要
        
        (client, players_table, decks_table)
    }

    #[tokio::test]
    async fn test_save_and_find_player() {
        let (client, players_table, decks_table) = setup_test_client().await;
        let repository = DynamoDbPlayerRepository::new(client, players_table, decks_table);
        
        let player_name = PlayerName::new("迅悠一".to_string()).unwrap();
        let deck_name = DeckName::new("テストデッキ".to_string()).unwrap();
        let player = Player::create(player_name.clone(), deck_name);
        
        // 保存
        repository.save(&player).await.unwrap();
        
        // 取得
        let found = repository.find_by_id(player.player_id()).await.unwrap();
        assert!(found.is_some());
        
        let found_player = found.unwrap();
        assert_eq!(found_player.player_name().value(), player.player_name().value());
    }

    #[tokio::test]
    async fn test_update_player() {
        let (client, players_table, decks_table) = setup_test_client().await;
        let repository = DynamoDbPlayerRepository::new(client, players_table, decks_table);
        
        let player_name = PlayerName::new("迅悠一".to_string()).unwrap();
        let deck_name = DeckName::new("テストデッキ".to_string()).unwrap();
        let mut player = Player::create(player_name, deck_name);
        
        repository.save(&player).await.unwrap();
        
        // 更新
        let new_name = PlayerName::new("迅".to_string()).unwrap();
        player.change_name(new_name.clone());
        repository.update(&player).await.unwrap();
        
        // 確認
        let updated = repository.find_by_id(player.player_id()).await.unwrap().unwrap();
        assert_eq!(updated.player_name().value(), "迅");
    }

    #[tokio::test]
    async fn test_delete_player() {
        let (client, players_table, decks_table) = setup_test_client().await;
        let repository = DynamoDbPlayerRepository::new(client, players_table, decks_table);
        
        let player_name = PlayerName::new("迅悠一".to_string()).unwrap();
        let deck_name = DeckName::new("テストデッキ".to_string()).unwrap();
        let player = Player::create(player_name, deck_name);
        
        repository.save(&player).await.unwrap();
        
        let found = repository.find_by_id(player.player_id()).await.unwrap();
        assert!(found.is_some());
        
        // 削除
        repository.delete(player.player_id()).await.unwrap();
        
        let deleted = repository.find_by_id(player.player_id()).await.unwrap();
        assert!(deleted.is_none());
    }

    #[tokio::test]
    async fn test_find_by_name() {
        let (client, players_table, decks_table) = setup_test_client().await;
        let repository = DynamoDbPlayerRepository::new(client, players_table, decks_table);
        
        let player_name = PlayerName::new("迅悠一".to_string()).unwrap();
        let deck_name = DeckName::new("テストデッキ".to_string()).unwrap();
        let player = Player::create(player_name.clone(), deck_name);
        
        repository.save(&player).await.unwrap();
        
        // 名前で検索
        let found = repository.find_by_name(&player_name).await.unwrap();
        assert!(found.is_some());
        
        let found_player = found.unwrap();
        assert_eq!(found_player.player_id().value(), player.player_id().value());
    }
}
```

> **Note:** DynamoDBを使ったテストでは、以下の方法があります：
> - **DynamoDB Local**: Dockerで実行できるローカル版DynamoDB（開発・テスト用）
> - **AWS テストアカウント**: 実際のDynamoDBを使用するが、テスト専用のAWSアカウントやテーブルを使用
> - **モックライブラリ**: `aws-sdk-dynamodb` のモックを使用（完全な動作確認はできない）
> 
> DynamoDB Localの起動例：
> ```bash
> docker run -p 8000:8000 amazon/dynamodb-local
> ```
> 
> テスト実行時は環境変数で接続先を指定：
> ```bash
> export AWS_ENDPOINT_URL=http://localhost:8000
> export AWS_REGION=ap-northeast-1
> export AWS_ACCESS_KEY_ID=dummy
> export AWS_SECRET_ACCESS_KEY=dummy
> ```

## Rustでのリポジトリ実装のポイント

### 1. トレイトによる抽象化

Rustでは `trait` を使ってリポジトリを抽象化します。`async_trait` クレートを使用すると非同期メソッドを持つトレイトを定義できます。

```rust
#[async_trait]
pub trait PlayerRepository: Send + Sync {
    async fn save(&self, player: &Player) -> Result<(), String>;
    // ...
}
```

### 2. Result型によるエラーハンドリング

データベース操作の結果は `Result` 型で返し、エラーを適切に処理します。

```rust
async fn save(&self, player: &Player) -> Result<(), String> {
    // データベース操作
    Ok(())
}
```

### 3. 依存性注入にはArc

複数の箇所でリポジトリを共有する場合、`Arc` を使用します。

```rust
use std::sync::Arc;

pub struct SomeService<R: PlayerRepository> {
    repository: Arc<R>,
}
```

### 4. reconstructメソッドの活用

データベースから取得したデータからドメインオブジェクトを再構築する際は、`reconstruct` メソッドを使用します。

```rust
let player = Player::reconstruct(player_id, player_name, level, deck);
```

### 5. DynamoDBのトランザクション管理

DynamoDBでは、トランザクションを以下のように管理できます。

```rust
use aws_sdk_dynamodb::types::{TransactWriteItem, Put};

async fn save_with_transaction(&self, player: &Player) -> Result<(), String> {
    let player_item = self.player_to_item(player);
    let deck_item = self.deck_to_item(player);
    
    // Playerアイテムの Put アクション
    let player_put = Put::builder()
        .table_name(&self.players_table)
        .set_item(Some(player_item))
        .build()
        .map_err(|e| format!("Build error: {}", e))?;
    
    // Deckアイテムの Put アクション
    let deck_put = Put::builder()
        .table_name(&self.decks_table)
        .set_item(Some(deck_item))
        .build()
        .map_err(|e| format!("Build error: {}", e))?;
    
    // トランザクション実行
    self.client
        .transact_write_items()
        .transact_items(
            TransactWriteItem::builder()
                .put(player_put)
                .build()
        )
        .transact_items(
            TransactWriteItem::builder()
                .put(deck_put)
                .build()
        )
        .send()
        .await
        .map_err(|e| format!("Transaction error: {}", e))?;
    
    Ok(())
}
```

### 6. DynamoDBの条件付き書き込み

楽観的ロックやバージョン管理には条件式を使用します。

```rust
async fn update_with_version_check(&self, player: &Player, expected_version: u32) -> Result<(), String> {
    self.client
        .update_item()
        .table_name(&self.players_table)
        .key("player_id", AttributeValue::S(player.player_id().value().to_string()))
        .update_expression("SET player_name = :name, version = version + :inc")
        .condition_expression("version = :expected")
        .expression_attribute_values(":name", AttributeValue::S(player.player_name().value().to_string()))
        .expression_attribute_values(":inc", AttributeValue::N("1".to_string()))
        .expression_attribute_values(":expected", AttributeValue::N(expected_version.to_string()))
        .send()
        .await
        .map_err(|e| format!("Conditional update failed: {}", e))?;
    
    Ok(())
}
```

### 7. バッチ操作

DynamoDBでは複数のアイテムをバッチで処理できます。

```rust
use aws_sdk_dynamodb::types::WriteRequest;

async fn batch_save(&self, players: Vec<&Player>) -> Result<(), String> {
    let mut write_requests = Vec::new();
    
    for player in players {
        let item = self.player_to_item(player);
        write_requests.push(
            WriteRequest::builder()
                .put_request(
                    aws_sdk_dynamodb::types::PutRequest::builder()
                        .set_item(Some(item))
                        .build()
                        .unwrap()
                )
                .build()
        );
    }
    
    // 最大25アイテムずつバッチ処理
    for chunk in write_requests.chunks(25) {
        self.client
            .batch_write_item()
            .request_items(&self.players_table, chunk.to_vec())
            .send()
            .await
            .map_err(|e| format!("Batch write error: {}", e))?;
    }
    
    Ok(())
}
```

## まとめ

- **リポジトリは、集約の永続化を行うためのトレイト（インターフェイス）**
- **リポジトリを利用することで、ドメイン層はデータベースアクセスの詳細を知る必要がなくなり、ドメインの知識に集中できるようになる**
- **抽象型である `PlayerRepository` トレイトに依存するようにすることで、具体的なデータベースアクセスの実装がなくても、ドメインサービスを実装することができる**
- **テストではインメモリリポジトリを使用することで、テストのセットアップを簡単にし、実行速度を向上させることができる**
- **DynamoDBとAWS SDK for Rustでは、`put_item`、`get_item`、`query`、`update_item`、`delete_item` などのAPIを使用してテスタブルなリポジトリを実装できる**
- **DynamoDBのトランザクション機能を使用することで、複数のテーブルにまたがる操作の一貫性を保証できる**

本章では、リポジトリついて学び、`PlayerNameDuplicationCheckDomainService` を完成させテストまで行いました。次章は、ユースケースの表現やドメインサービスのクライアントでもあるアプリケーションサービスについて学びます。
